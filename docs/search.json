[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Intro to SQL",
    "section": "",
    "text": "Intro to SQL",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#course-description",
    "href": "index.html#course-description",
    "title": "Intro to SQL",
    "section": "Course Description",
    "text": "Course Description\nData that we need to utilize and query is often stored in data sources such as databases or data warehouses. In this course, you will learn how to connect and query databases using Structured Query Language (SQL). In particular, we will focus on querying data in a commonly used data model for storing patient data called OMOP. By the end of this course, you will be prepared to construct complex queries to retrieve large data sets and automate these queries to produce automated reports and dashboards.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "Intro to SQL",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nExplain data sources such as Databases and how to connect to them\nQuery data sources using database engines and Structured Query Language (SQL) to filter, join, and aggregate data\nConstruct and calculate new fields using SELECT or CASE WHEN\n(optional) Read and explain a sample OMOP query: https://github.com/OHDSI/OMOP-Queries/tree/master",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#instructors",
    "href": "index.html#instructors",
    "title": "Intro to SQL",
    "section": "Instructors",
    "text": "Instructors\nIf you need to schedule some time to talk, please schedule with Chris.\n\nTed Laderas, Director of Training and Community, Office of the Chief Data Officer\nVivek Sriram, Data Scientist, Office of the Chief Data Officer",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#introductions",
    "href": "index.html#introductions",
    "title": "Intro to SQL",
    "section": "Introductions",
    "text": "Introductions\nIn chat, please introduce yourself:\n\nYour Name & Your Group\nWhat you want to learn in this course\nFavorite Winter activity",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#tentative-schedule",
    "href": "index.html#tentative-schedule",
    "title": "Intro to SQL",
    "section": "Tentative Schedule",
    "text": "Tentative Schedule\nAll classes are on Fridays from 12:00-1:30 PM PST. Connection details will be provided. Office hours related to each class day are posted below, and the invite will be sent to you.\nIn class we will be going through the Quarto Notebooks that are hosted on Posit.cloud. No knowledge of R is necessary, we’ll show you what you need to know in class.\nClasses will be recorded, and those recordings will be sent to you after each class.\n\n\n\nWeek\nDate\nSubject\n\n\n\n\nPre-class\n—-\nConcepts of Databases\n\n\n1\nFeb 6\nIntro to SQL; SHOW TABLES, DESCRIBE, SELECT, WHERE\n\n\n2\nFeb 13\nJOINing tables, more WHERE\n\n\nNo class!\nFeb 20\nSpring Break (No class)\n\n\n3\nFeb 27\nCalculating new fields, GROUP BY, CASE WHEN, HAVING\n\n\n4\nMar 6\nSubqueries/Views, Recap of course / review OMOP queries",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#format-of-class",
    "href": "index.html#format-of-class",
    "title": "Intro to SQL",
    "section": "Format of Class",
    "text": "Format of Class\nThe course will be taught in a hybrid form. Come to M1-B406 to learn in-person, and enjoy the snacks. Or join online via the Teams on your calendar.\nWe will spend the first 20-25 minutes of each class on catching up on last week’s exercises if you haven’t had the opportunity to work on them. Followed by that, we will have a short lecture/lab, where we will go through the notebooks for the week.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#first-class-survey",
    "href": "index.html#first-class-survey",
    "title": "Intro to SQL",
    "section": "First Class Survey",
    "text": "First Class Survey\nFirst Class Survey - Please fill out. We mostly want to see how confident you are before and after class. We will share these results with everyone (anonymized).",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#weekly-check-in",
    "href": "index.html#weekly-check-in",
    "title": "Intro to SQL",
    "section": "Weekly Check In",
    "text": "Weekly Check In\nWeekly Check In Form - please fill out to let us know if you have any issues or want to share what you’ve learned. We look at the answers in aggregate and we anonymize responses (unless you want us to know).",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#posit-cloud-intro",
    "href": "index.html#posit-cloud-intro",
    "title": "Intro to SQL",
    "section": "Posit Cloud Intro",
    "text": "Posit Cloud Intro\nHere is a short video introducing you to the Posit Cloud interface.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#culture-of-the-course",
    "href": "index.html#culture-of-the-course",
    "title": "Intro to SQL",
    "section": "Culture of the course",
    "text": "Culture of the course\n\nLearning on the job is challenging\n\nI will move at learner’s pace; we are learning together.\nTeach not for mastery, but teach for empowerment to learn effectively.\n\n\nWe sometimes struggle with our data science in isolation, unaware that someone two doors down from us has gone through the same struggle.\n\nWe learn and work better with our peers.\nKnow that if you have a question, other people will have it.\nAsking questions is our way of taking care of others.\n\nWe ask you to follow Participation Guidelines and Code of Conduct.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#posit-cloud-project",
    "href": "index.html#posit-cloud-project",
    "title": "Intro to SQL",
    "section": "Posit Cloud Project",
    "text": "Posit Cloud Project\nFor those who are not Fred Hutch learners and want to try the course out, we have an Posit.cloud Project that you can clone to your own account: https://posit.cloud/content/10022544",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#badge-of-completion",
    "href": "index.html#badge-of-completion",
    "title": "Intro to SQL",
    "section": "Badge of completion",
    "text": "Badge of completion\n\nWe offer a badge of completion when you finish the course!\nWhat it is:\n\nA display of what you accomplished in the course, shareable in your professional networks such as LinkedIn, similar to online education services such as Coursera.\n\nWhat it isn’t:\n\nAccreditation through an university or degree-granting program.\n\nRequirements:\n\nComplete for 3 out of 4 assignments.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#available-course-formats",
    "href": "index.html#available-course-formats",
    "title": "Intro to SQL",
    "section": "Available Course Formats",
    "text": "Available Course Formats\nThis course is available in multiple formats which allows you to take it in the way that best suites your needs.\n\nThe material for this course can be viewed without login requirement on this website. This format might be most appropriate for you if you rely on screen-reader technology.\nThe material is also available to Fred Hutch Consortia students via Posit Cloud.\nOur courses are open source, you can find the source material for this course on GitHub.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "concepts.html",
    "href": "concepts.html",
    "title": "\n1  Database Concepts\n",
    "section": "",
    "text": "1.1 What is a Database?\nWhen we talk about databases, we often mean the database system rather than database itself. Specifically, we talk about the different layers of a database system.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#what-is-a-database",
    "href": "concepts.html#what-is-a-database",
    "title": "\n1  Database Concepts\n",
    "section": "",
    "text": "A database is an organized collection of structured information, or data, typically stored electronically in a computer system. A database is usually controlled by a database management system (DBMS). Together, the data and the DBMS, along with the applications that are associated with them, are referred to as a database system, often shortened to just database. - Oracle Documentation",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#parts-of-a-database-system",
    "href": "concepts.html#parts-of-a-database-system",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.2 Parts of a Database System",
    "text": "1.2 Parts of a Database System\nThe Composable Codex talks about three layers of a database system:\nFrom the Composable Codex\n\n\nA user interface - how users interact with the database. In this class, our main way of interacting with databases is SQL (Structured Query Language).\n\nAn execution engine - a software system that queries the data in storage. There are many examples of this: SQL Server, MariaDB, DuckDB, Snowflake. These can live on our machine, on a server within our network, or a server on the cloud.\n\nData Storage - the physical location where the data is stored. This could be on your computer, on the network, or in the cloud (such as an Amazon S3 bucket)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#for-this-class",
    "href": "concepts.html#for-this-class",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.3 For this class",
    "text": "1.3 For this class\nIn our class, we will use the following configuration:\n\n\n\n\n\ngraph TD\nA[\"1.SQL\"] --&gt; B\nB[\"2.DuckDB\"] --&gt; C\nC[\"3.File on our Machine\"]\n\n\n\n\n\n\n\n\n\n\n\n\nNoneWhy We’re Using DuckDB in this Course\n\n\n\nDuckDB is a very fast, open-source database engine. Because of restrictions on clinical data, sometimes the only way to analyze it is on an approved laptop. DuckDB does wondrous things on laptops, so we hope it will be a helpful tool in your arsenal.\nIt is what is called an analytical database engine, which means it is very fast for reading and querying data. This is compared to a transactional database engine, which must handle multiple users interacting and inserting data into the database at once.\n\n\nBut you can think of other configurations that might be more applicable to you. For example, a lot of groups at the Hutch use SQL Server:\n\n\n\n\n\ngraph TD\nA[\"1.SQL\"] --&gt; B\nB[\"2.SQL Server\"] --&gt; C\nC[\"3.FH Shared Storage\"]\n\n\n\n\n\n\nIn many ways, SQL Server and its storage are tightly coupled (the engine and the storage are in the same location). This coupling can make it difficult to migrate out of such systems.\nOr, for those who want to use cloud-based systems, we can have this configuration:\n\n\n\n\n\ngraph TD\nA[\"1.SQL/Notebooks\"] --&gt; B\nB[\"2.Databricks/Snowflake\"] --&gt; C\nC[\"3.Amazon S3\"]\n\n\n\n\n\n\nIn this case, we need to sign into the Databricks system, which is a set of systems that lives in the cloud. We actually will use SQL within their notebooks to write our queries. Databricks will then use the Snowflake engine to query the data that is stored in cloud storage (an S3 bucket).\nIf this is making you dizzy, don’t worry too much about it. Just know that we can switch out the different layers based on our needs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#our-underlying-data-model",
    "href": "concepts.html#our-underlying-data-model",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.4 Our underlying data model",
    "text": "1.4 Our underlying data model\nThe three components of our Database System is dependent on our choice of the data model. Most data models are centered around Relational Databases. A relational database organizes data into multiple tables. Each table’s row is a record with a unique ID called the key, as well as attributes described in the columns. The tables may relate to each other based on columns with the same values.\nBelow is an example entity-relationship diagram that summarizes relationships between tables:\n\nEach rectangle represent a table, and within each table are the columns (fields). The connecting lines shows that there are shared values between tables in those columns, which helps one navigate between tables. Don’t worry if this feels foreign to you right now - we will unpack these diagrams throughout the course.\nOther data models include NoSQL (“Not Only SQL”), which allows the organization of unstructured data via key-value pairs, graphs, and encoding entire documents. Another emerging data model are Array/Matrix/Vector-based models, which are largely focused on organizing numerical data for machine learning purposes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#what-is-sql",
    "href": "concepts.html#what-is-sql",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.5 What is SQL?",
    "text": "1.5 What is SQL?\nSQL is short for Structured Query Language. It is a standardized language for querying relational databases.\nSQL lets us do various operations on data. It contains various clauses which let us manipulate data:\n\n\n\n\n\n\n\nPriority\nClause\nPurpose\n\n\n\n1\nFROM\nChoose tables to query and specify how to JOIN them together\n\n\n2\nWHERE\nFilter tables based on criteria\n\n\n3\nGROUP BY\nAggregates the Data\n\n\n4\nHAVING\nFilters Aggregated Data\n\n\n5\nSELECT\nSelects columns in table and calculate new columns\n\n\n6\nORDER BY\nSorts by a database field\n\n\n7\nLIMIT\nLimits the number of records returned\n\n\n\nWe do not use all of these clauses when we write a SQL Query. We only use the ones we need to get the data we need out.\nOftentimes, we really only want a summary out of the database. We would probably use the following clauses:\n\n\n\n\n\n\n\nPriority\nClause\nPurpose\n\n\n\n1\nFROM\nChoose tables to query and specify how to JOIN them together\n\n\n2\nWHERE\nFilter tables based on criteria\n\n\n3\nGROUP BY\nAggregates the Data\n\n\n5\nSELECT\nSelects columns in table and calculate new columns\n\n\n\nNotice that there is a Priority column in these tables. This is important, because parts of queries are evaluated in this order.\n\n\n\n\n\n\nNoteDialects of SQL\n\n\n\nYou may have heard that the SQL used in SQL Server is different than other databases. In truth, there are multiple dialects of SQL, based on the engine.\nHowever, we’re focusing on the 95% of SQL that is common to all systems. Most of the time, the SQL we’re showing you in this course will get you to where you want to go.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#anatomy-of-a-sql-statement",
    "href": "concepts.html#anatomy-of-a-sql-statement",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.6 Anatomy of a SQL Statement",
    "text": "1.6 Anatomy of a SQL Statement\nLet’s look at a typical SQL statement:\nSELECT person_id, gender_source_value   # Choose Columns\n  FROM person                           # Choose the person table\n  WHERE year_of_birth &lt; 2000;            # Filter the data using a criterion\nWe can read this as:\nSELECT the person_id and gender_source_value columns\nFROM the person table\nONLY Those with year of birth less than 2000 \nAs you can see, SQL can be read. We will gradually introduce clauses and different database operations.\n\n\n\n\n\n\nNote\n\n\n\nAs a convention, we will capitalize SQL clauses (such as SELECT), and use lowercase for everything else.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#database-connections",
    "href": "concepts.html#database-connections",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.7 Database Connections",
    "text": "1.7 Database Connections\nWe haven’t really talked about how we connect to the database engine.\nIn order to connect to the database engine and create a database connection, we may have to authenticate with an ID/password combo or use other methods of authentication to prove who we are.\nOnce we are authenticated, we now have a connection. This is basically our conduit to the database engine. We can send queries through it, and the database engine will run these queries, and return a result.\n\n\n\n\n\ngraph LR\n  A[\"Our Computer\"] --query--&gt; B[Database Engine]\n  B --results--&gt; A\n\n\n\n\n\n\nAs long as the connection is open, we can continue to send queries and receive results.\nIt is best practice to explicitly disconnect from the database. Once we have disconnected, we no longer have access to the database.\n\n\n\n\n\ngraph LR\n  A[\"Our Computer\"] --X--&gt; B[Database Engine]\n  B --X--&gt; A",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#how-is-the-data-stored",
    "href": "concepts.html#how-is-the-data-stored",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.8 How is the Data Stored?",
    "text": "1.8 How is the Data Stored?\nTypically, the data in databases is stored in tables, such as the one below:\n\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nperson_id\ngender_concept_id\nyear_of_birth\nmonth_of_birth\nday_of_birth\nbirth_datetime\nrace_concept_id\nethnicity_concept_id\nlocation_id\nprovider_id\ncare_site_id\nperson_source_value\ngender_source_value\ngender_source_concept_id\nrace_source_value\nrace_source_concept_id\nethnicity_source_value\nethnicity_source_concept_id\n\n\n\n6\n8532\n1963\n12\n31\n1963-12-31\n8516\n0\nNA\nNA\nNA\n001f4a87-70d0-435c-a4b9-1425f6928d33\nF\n0\nblack\n0\nwest_indian\n0\n\n\n123\n8507\n1950\n4\n12\n1950-04-12\n8527\n0\nNA\nNA\nNA\n052d9254-80e8-428f-b8b6-69518b0ef3f3\nM\n0\nwhite\n0\nitalian\n0\n\n\n129\n8507\n1974\n10\n7\n1974-10-07\n8527\n0\nNA\nNA\nNA\n054d32d5-904f-4df4-846b-8c08d165b4e9\nM\n0\nwhite\n0\npolish\n0\n\n\n16\n8532\n1971\n10\n13\n1971-10-13\n8527\n0\nNA\nNA\nNA\n00444703-f2c9-45c9-a247-f6317a43a929\nF\n0\nwhite\n0\namerican\n0\n\n\n65\n8532\n1967\n3\n31\n1967-03-31\n8516\n0\nNA\nNA\nNA\n02a3dad9-f9d5-42fb-8074-c16d45b4f5c8\nF\n0\nblack\n0\ndominican\n0\n\n\n74\n8532\n1972\n1\n5\n1972-01-05\n8527\n0\nNA\nNA\nNA\n02fbf1be-29b7-4da8-8bbd-14c7433f843f\nF\n0\nwhite\n0\nenglish\n0\n\n\n42\n8532\n1909\n11\n2\n1909-11-02\n8527\n0\nNA\nNA\nNA\n0177d2e0-98f5-4f3d-bcfd-497b7a07b3f8\nF\n0\nwhite\n0\nirish\n0\n\n\n187\n8507\n1945\n7\n23\n1945-07-23\n8527\n0\nNA\nNA\nNA\n07a1e14d-73ed-4d3a-9a39-d729745773fa\nM\n0\nwhite\n0\nirish\n0\n\n\n18\n8532\n1965\n11\n17\n1965-11-17\n8527\n0\nNA\nNA\nNA\n0084b0fe-e30f-4930-b6d1-5e1eff4b7dea\nF\n0\nwhite\n0\nenglish\n0\n\n\n111\n8532\n1975\n5\n2\n1975-05-02\n8527\n0\nNA\nNA\nNA\n0478d6b3-bdb3-4574-9b93-cf448d725b84\nF\n0\nwhite\n0\nenglish\n0\n\n\n\n\n\nSome quick terminology:\n\n\nDatabase Record - a row in this table. In this case, each row in the table above corresponds to a single person.\n\nDatabase Field - the columns in this table. In our case, each column corresponds to a single measurement, such as birth_datetime. Each column has a specific datatype, which may be integers, decimals, dates, a short text field, or longer text fields. Think of them like the different pieces of information requested in a form.\n\nIt is faster and requires less memory if we do not use a single large table, but decompose the data up into multiple tables. These tables are stored in a number of different formats:\n\nComma Separated Value (CSV)\nA Single File (SQL Server)\na virtual file\n\n\nIn a virtual file, the data acts like it is stored in a single file, but is actually many different files underneath that can be on your machine, on the network, or on the cloud. The virtual file lets us interact with this large mass of data as if it is a single file.\nThe database engine is responsible for scanning the data, either row by row, or column by column. The engines are made to be very fast in this scanning to return relevant records.\n\n\n\n\n\n\nNoneRows versus Columns\n\n\n\nJust a quick note about row-based storage vs column-based storage. SQL was originally written for relational databases, which are stored by row.\nA new trick is column-based storage. It turns out that it’s actually faster to query the data in many instances when the data in a column is all stored together. These are the formats like Parquet that you might have heard about. A lot of newer database engines rely on the data to be stored in this format.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "week1.html",
    "href": "week1.html",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "",
    "text": "2.1 Our Database Management System (DBMS) for this course",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#our-database-management-system-dbms-for-this-course",
    "href": "week1.html#our-database-management-system-dbms-for-this-course",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "",
    "text": "Client: R/RStudio w/ SQL\nDatabase Engine: DuckDB\nData Storage: single file in data/ folder",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#connecting-to-our-database",
    "href": "week1.html#connecting-to-our-database",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.2 Connecting to our database",
    "text": "2.2 Connecting to our database\nTo access the data, we need to create a database connection. We use dbConnect() from the DBI package to do this. The first argument specifies the Database engine (duckdb()), and the second provides the file location: \"data/data/GiBleed_5.3_1.1.duckdb\".\n\nlibrary(duckdb)\n\nLoading required package: DBI\n\nlibrary(DBI)\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), \"data/GiBleed_5.3_1.1.duckdb\")\n\nOnce open, we can use con (our database connection)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#keep-in-mind-sql-ignores-letter-case",
    "href": "week1.html#keep-in-mind-sql-ignores-letter-case",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.3 Keep in Mind: SQL ignores letter case",
    "text": "2.3 Keep in Mind: SQL ignores letter case\nThese are the same to the database engine:\nSELECT person_id FROM person;\nselect PERSON_ID FROM person;\nAnd so on. Our convention is that we capitalize SQL clauses such as SELECT so you can differentiate them from other information.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#looking-at-the-entire-database",
    "href": "week1.html#looking-at-the-entire-database",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.4 Looking at the Entire Database",
    "text": "2.4 Looking at the Entire Database\nOne of the first things we can learn is to show the contents of the entire database; we can do this with SHOW TABLES:\n\nSHOW TABLES;\n\n\nDisplaying records 1 - 10\n\nname\n\n\n\ncare_site\n\n\ncdm_source\n\n\nconcept\n\n\nconcept_ancestor\n\n\nconcept_class\n\n\nconcept_relationship\n\n\nconcept_synonym\n\n\ncondition_era\n\n\ncondition_occurrence\n\n\ncost\n\n\n\n\n\nWe can get further information about the tables within our database using DESCRIBE; This will give us more information about individual tables:\n\nDESCRIBE;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\ndatabase\nschema\nname\ncolumn_names\ncolumn_types\ntemporary\n\n\n\nGiBleed_5\nmain\ncare_site\ncare_site_id , care_site_name , place_of_service_concept_id , location_id , care_site_source_value , place_of_service_source_value\nINTEGER, VARCHAR, INTEGER, INTEGER, VARCHAR, VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\ncdm_source\ncdm_source_name , cdm_source_abbreviation , cdm_holder , source_description , source_documentation_reference, cdm_etl_reference , source_release_date , cdm_release_date , cdm_version , vocabulary_version\nVARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, DATE , DATE , VARCHAR, VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\nconcept\nconcept_id , concept_name , domain_id , vocabulary_id , concept_class_id, standard_concept, concept_code , valid_start_date, valid_end_date , invalid_reason\nINTEGER, VARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, DATE , DATE , VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\nconcept_ancestor\nancestor_concept_id , descendant_concept_id , min_levels_of_separation, max_levels_of_separation\nINTEGER, INTEGER, INTEGER, INTEGER\nFALSE\n\n\nGiBleed_5\nmain\nconcept_class\nconcept_class_id , concept_class_name , concept_class_concept_id\nVARCHAR, VARCHAR, INTEGER\nFALSE\n\n\nGiBleed_5\nmain\nconcept_relationship\nconcept_id_1 , concept_id_2 , relationship_id , valid_start_date, valid_end_date , invalid_reason\nINTEGER, INTEGER, VARCHAR, DATE , DATE , VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\nconcept_synonym\nconcept_id , concept_synonym_name, language_concept_id\nINTEGER, VARCHAR, INTEGER\nFALSE\n\n\nGiBleed_5\nmain\ncondition_era\ncondition_era_id , person_id , condition_concept_id , condition_era_start_date , condition_era_end_date , condition_occurrence_count\nINTEGER, INTEGER, INTEGER, DATE , DATE , INTEGER\nFALSE\n\n\nGiBleed_5\nmain\ncondition_occurrence\ncondition_occurrence_id , person_id , condition_concept_id , condition_start_date , condition_start_datetime , condition_end_date , condition_end_datetime , condition_type_concept_id , condition_status_concept_id , stop_reason , provider_id , visit_occurrence_id , visit_detail_id , condition_source_value , condition_source_concept_id , condition_status_source_value\nINTEGER , INTEGER , INTEGER , DATE , TIMESTAMP, DATE , TIMESTAMP, INTEGER , INTEGER , VARCHAR , INTEGER , INTEGER , INTEGER , VARCHAR , INTEGER , VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\ncost\ncost_id , cost_event_id , cost_domain_id , cost_type_concept_id , currency_concept_id , total_charge , total_cost , total_paid , paid_by_payer , paid_by_patient , paid_patient_copay , paid_patient_coinsurance , paid_patient_deductible , paid_by_primary , paid_ingredient_cost , paid_dispensing_fee , payer_plan_period_id , amount_allowed , revenue_code_concept_id , revenue_code_source_value, drg_concept_id , drg_source_value\nINTEGER, INTEGER, VARCHAR, INTEGER, INTEGER, FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , INTEGER, FLOAT , INTEGER, VARCHAR, INTEGER, VARCHAR\nFALSE\n\n\n\n\n\nWe’ll look at a few tables in our work:\n\n\nperson - Contains personal & demographic data\n\nprocedure_occurrence - procedures performed on patients and when they happened\n\nconcept - contains the specific information (names of concepts) that map into all three above tables",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#describing-a-table",
    "href": "week1.html#describing-a-table",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.5 Describing a table",
    "text": "2.5 Describing a table\nWe can use DESCRIBE to get more information (the metadata) about a table.\n\nDESCRIBE person\n\n\nDisplaying records 1 - 10\n\ncolumn_name\ncolumn_type\nnull\nkey\ndefault\nextra\n\n\n\nperson_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\ngender_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nyear_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nmonth_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nday_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nbirth_datetime\nTIMESTAMP\nYES\nNA\nNA\nNA\n\n\nrace_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nethnicity_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nlocation_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprovider_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\n\n\n\nWe will pay attention to column_name and column_type for the moment.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#data-types",
    "href": "week1.html#data-types",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.6 Data Types",
    "text": "2.6 Data Types\nIf you look at the column_type for one of the DESCRIBE statements above, you’ll notice there are different data types:\n\nINTEGER\nTIMESTAMP\nDATE\nVARCHAR\n\nEach column of a database needs to be typed. The data type of a column determines what kinds of calculations or operations we can do on them. For example, we can do things like date arithmetic on DATETIME columns, asking the engine to calculate 5 days after the dates.\nYou can see all of the datatypes that are available in DuckDB here.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#select-and-from",
    "href": "week1.html#select-and-from",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.7 SELECT and FROM\n",
    "text": "2.7 SELECT and FROM\n\nIf we want to see the contents of a table, we can use SELECT and FROM.\nSELECT *          # select all columns\n  FROM person     # from the person table\n  LIMIT 10;       # return only 10 rows\n\nSELECT * \n  FROM person \n  LIMIT 10;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nperson_id\ngender_concept_id\nyear_of_birth\nmonth_of_birth\nday_of_birth\nbirth_datetime\nrace_concept_id\nethnicity_concept_id\nlocation_id\nprovider_id\ncare_site_id\nperson_source_value\ngender_source_value\ngender_source_concept_id\nrace_source_value\nrace_source_concept_id\nethnicity_source_value\nethnicity_source_concept_id\n\n\n\n6\n8532\n1963\n12\n31\n1963-12-31\n8516\n0\nNA\nNA\nNA\n001f4a87-70d0-435c-a4b9-1425f6928d33\nF\n0\nblack\n0\nwest_indian\n0\n\n\n123\n8507\n1950\n4\n12\n1950-04-12\n8527\n0\nNA\nNA\nNA\n052d9254-80e8-428f-b8b6-69518b0ef3f3\nM\n0\nwhite\n0\nitalian\n0\n\n\n129\n8507\n1974\n10\n7\n1974-10-07\n8527\n0\nNA\nNA\nNA\n054d32d5-904f-4df4-846b-8c08d165b4e9\nM\n0\nwhite\n0\npolish\n0\n\n\n16\n8532\n1971\n10\n13\n1971-10-13\n8527\n0\nNA\nNA\nNA\n00444703-f2c9-45c9-a247-f6317a43a929\nF\n0\nwhite\n0\namerican\n0\n\n\n65\n8532\n1967\n3\n31\n1967-03-31\n8516\n0\nNA\nNA\nNA\n02a3dad9-f9d5-42fb-8074-c16d45b4f5c8\nF\n0\nblack\n0\ndominican\n0\n\n\n74\n8532\n1972\n1\n5\n1972-01-05\n8527\n0\nNA\nNA\nNA\n02fbf1be-29b7-4da8-8bbd-14c7433f843f\nF\n0\nwhite\n0\nenglish\n0\n\n\n42\n8532\n1909\n11\n2\n1909-11-02\n8527\n0\nNA\nNA\nNA\n0177d2e0-98f5-4f3d-bcfd-497b7a07b3f8\nF\n0\nwhite\n0\nirish\n0\n\n\n187\n8507\n1945\n7\n23\n1945-07-23\n8527\n0\nNA\nNA\nNA\n07a1e14d-73ed-4d3a-9a39-d729745773fa\nM\n0\nwhite\n0\nirish\n0\n\n\n18\n8532\n1965\n11\n17\n1965-11-17\n8527\n0\nNA\nNA\nNA\n0084b0fe-e30f-4930-b6d1-5e1eff4b7dea\nF\n0\nwhite\n0\nenglish\n0\n\n\n111\n8532\n1975\n5\n2\n1975-05-02\n8527\n0\nNA\nNA\nNA\n0478d6b3-bdb3-4574-9b93-cf448d725b84\nF\n0\nwhite\n0\nenglish\n0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#try-it-out",
    "href": "week1.html#try-it-out",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.8 Try it Out",
    "text": "2.8 Try it Out\nLook at the first few rows of procedure_occurrence.\n\nSELECT * \n  FROM ____ \n  LIMIT 10;\n\n\nWhy is there a person_id column in this table as well?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#selecting-a-few-columns-in-our-table",
    "href": "week1.html#selecting-a-few-columns-in-our-table",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.9 SELECTing a few columns in our table",
    "text": "2.9 SELECTing a few columns in our table\nWe can use the SELECT clause to grab specific columns in our data.\nSELECT person_id, birth_datetime, gender_concept_id # Columns in our table\n  FROM person;                                      # Our Table\n\nSELECT person_id, birth_datetime, gender_concept_id \n  FROM person\n  LIMIT 10;\n\n\nDisplaying records 1 - 10\n\nperson_id\nbirth_datetime\ngender_concept_id\n\n\n\n6\n1963-12-31\n8532\n\n\n123\n1950-04-12\n8507\n\n\n129\n1974-10-07\n8507\n\n\n16\n1971-10-13\n8532\n\n\n65\n1967-03-31\n8532\n\n\n74\n1972-01-05\n8532\n\n\n42\n1909-11-02\n8532\n\n\n187\n1945-07-23\n8507\n\n\n18\n1965-11-17\n8532\n\n\n111\n1975-05-02\n8532",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#try-it-out-1",
    "href": "week1.html#try-it-out-1",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.10 Try it Out",
    "text": "2.10 Try it Out\nWhat happens if we ask for a column that doesn’t exist in our data?\n\nSELECT person_id, birth_datetime, gender_concept_id, blah\n  FROM person;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#check-on-learning",
    "href": "week1.html#check-on-learning",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.11 Check on Learning",
    "text": "2.11 Check on Learning\nAdd race_concept_id and year_of_birth to your SELECT query:\n\nSELECT person_id, birth_datetime, gender_concept_id, ____, ____\n  FROM person;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#where---filtering-our-table",
    "href": "week1.html#where---filtering-our-table",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.12 WHERE - filtering our table",
    "text": "2.12 WHERE - filtering our table\nAdding WHERE to our SQL statement lets us add filtering to our query:\n\nSELECT person_id, gender_source_value, race_source_value, year_of_birth \n  FROM person \n  WHERE year_of_birth &lt; 2000\n\n\nDisplaying records 1 - 10\n\nperson_id\ngender_source_value\nrace_source_value\nyear_of_birth\n\n\n\n6\nF\nblack\n1963\n\n\n123\nM\nwhite\n1950\n\n\n129\nM\nwhite\n1974\n\n\n16\nF\nwhite\n1971\n\n\n65\nF\nblack\n1967\n\n\n74\nF\nwhite\n1972\n\n\n42\nF\nwhite\n1909\n\n\n187\nM\nwhite\n1945\n\n\n18\nF\nwhite\n1965\n\n\n111\nF\nwhite\n1975\n\n\n\n\n\nOne critical thing to know is that you don’t need to include the columns you’re filtering on in the SELECT part of the statement. For example, we could do the following as well, removing year_of_birth from our SELECT:\n\nSELECT person_id, gender_source_value, race_source_value \n  FROM person \n  WHERE year_of_birth &lt; 2000\n\n\nDisplaying records 1 - 10\n\nperson_id\ngender_source_value\nrace_source_value\n\n\n\n6\nF\nblack\n\n\n123\nM\nwhite\n\n\n129\nM\nwhite\n\n\n16\nF\nwhite\n\n\n65\nF\nblack\n\n\n74\nF\nwhite\n\n\n42\nF\nwhite\n\n\n187\nM\nwhite\n\n\n18\nF\nwhite\n\n\n111\nF\nwhite\n\n\n\n\n\n\n2.12.1 Single quotes and WHERE\n\nSQL convention: single quotes (‘M’) refer to values, and double quotes refer to columns (“person_id”). If you try to use double quotes in the below, it will look for a column called “M”.\nThis will trip you up several times if you’re not used to it.\n\nSELECT person_id, gender_source_value \n  FROM person \n  WHERE gender_source_value = 'M'\n  LIMIT 10;\n\n\nDisplaying records 1 - 10\n\nperson_id\ngender_source_value\n\n\n\n123\nM\n\n\n129\nM\n\n\n187\nM\n\n\n40\nM\n\n\n53\nM\n\n\n78\nM\n\n\n69\nM\n\n\n248\nM\n\n\n105\nM\n\n\n49\nM\n\n\n\n\n\nReminder: use single (’’) quotes in your SQL statements to refer to values, not double quotes (“).\n\n2.12.2 Quick Note\nFor R users, notice the similarity of select() with SELECT. We can rewrite the above in dplyr code as:\nperson |&gt;\n  select(person_id, gender_source_value, race_source_value)\nA lot of dplyr was inspired by SQL. In fact, there is a package called dbplyr that translates dplyr statements into SQL. A lot of us use it, and it’s pretty handy.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#count---how-many-entries",
    "href": "week1.html#count---how-many-entries",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.13 COUNT - how many entries?",
    "text": "2.13 COUNT - how many entries?\nSometimes you want to know the size of your result, not necessarily return the entire set of results. That is what COUNT is for.\n\nSELECT COUNT(*)\n  FROM procedure_occurrence;\n\n\n1 records\n\ncount_star()\n\n\n37409\n\n\n\n\nSimilarly, when we want to count the number of person_ids returned, we can use COUNT(person_id):\n\nSELECT COUNT(procedure_concept_id)\n  FROM procedure_occurrence;\n\n\n1 records\n\ncount(procedure_concept_id)\n\n\n37409\n\n\n\n\nThere are repeat procedure_concept_ids in the procedure_occurrence table. When you have repeated values in the rows, COUNT(DISTINCT ) can help you find the number of unique values in a column:\n\nSELECT COUNT(DISTINCT procedure_concept_id)\n  FROM procedure_occurrence\n\n\n1 records\n\ncount(DISTINCT procedure_concept_id)\n\n\n51\n\n\n\n\nWe can also return the actual DISTINCT values by removing COUNT:\n\nSELECT DISTINCT procedure_concept_id\n  FROM procedure_occurrence;\n\n\nDisplaying records 1 - 10\n\nprocedure_concept_id\n\n\n\n4243062\n\n\n4336464\n\n\n4337138\n\n\n44805732\n\n\n4230209\n\n\n4058899\n\n\n4295880\n\n\n4216130\n\n\n4024289\n\n\n4202451",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#check-on-learning-1",
    "href": "week1.html#check-on-learning-1",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.14 Check on Learning",
    "text": "2.14 Check on Learning\nCount the distinct values of gender_source_value in person:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#revisiting-describe",
    "href": "week1.html#revisiting-describe",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.15 Revisiting DESCRIBE\n",
    "text": "2.15 Revisiting DESCRIBE\n\nLet’s return to our table metadata and look at it more in depth:\n\nDESCRIBE person\n\n\nDisplaying records 1 - 10\n\ncolumn_name\ncolumn_type\nnull\nkey\ndefault\nextra\n\n\n\nperson_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\ngender_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nyear_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nmonth_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nday_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nbirth_datetime\nTIMESTAMP\nYES\nNA\nNA\nNA\n\n\nrace_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nethnicity_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nlocation_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprovider_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\n\n\n\nOne of the important properties of data in a relational database is that there are no repeat rows in the database. Each table that meets this restriction has what is called a primary key.\nScanning the rows, which field/column is the primary key for person?\nTry and find the primary key for procedure_occurrence. What is it?\n\nDESCRIBE procedure_occurrence\n\n\nDisplaying records 1 - 10\n\ncolumn_name\ncolumn_type\nnull\nkey\ndefault\nextra\n\n\n\nprocedure_occurrence_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nperson_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprocedure_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprocedure_date\nDATE\nYES\nNA\nNA\nNA\n\n\nprocedure_datetime\nTIMESTAMP\nYES\nNA\nNA\nNA\n\n\nprocedure_type_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nmodifier_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nquantity\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprovider_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nvisit_occurrence_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\n\n\n\nWe'll see that primary keys need to be unique (so they can map to each row).\nWhat column is the same in both tables? That is a hint for what we'll cover next week: JOINing tables.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week1.html#always-close-the-connection",
    "href": "week1.html#always-close-the-connection",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.16 Always close the connection",
    "text": "2.16 Always close the connection\nWhen we’re done, it’s best to close the connection with dbDisconnect().\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: DESCRIBE, SELECT, WHERE</span>"
    ]
  },
  {
    "objectID": "week2.html",
    "href": "week2.html",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "",
    "text": "3.1 Connecting to our database\nLet’s connect to our database.\nlibrary(duckdb)\n\nLoading required package: DBI\n\nlibrary(DBI)\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), \n                      \"data/GiBleed_5.3_1.1.duckdb\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#table-references",
    "href": "week2.html#table-references",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.2 Table References",
    "text": "3.2 Table References\nIn single table queries, it is usually unambiguous to the query engine which column and which table you need to query.\nHowever, when you involve multiple tables, it is important to know how to refer to a column in a specific table.\nFor example, the procedure_occurrence table has a person_id column as well. If we want to use this specific column in this table, we can use the . (dot) notation:\nprocedure_occurrence.person_id\nIf we wanted the person_id column in person we can use this:\nperson.person_id\nThis will become much more important as we get into JOINing tables.\n\n3.2.1 Check on Learning\nAdd table references to the WHERE part of the query:\n\nSELECT *\n  FROM procedure_occurrence\n  WHERE person_id = 1\n\nLet’s get ready to work on queries involving multiple tables.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#entity-relationship-diagrams",
    "href": "week2.html#entity-relationship-diagrams",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.3 Entity-relationship diagrams",
    "text": "3.3 Entity-relationship diagrams\nJoining tables require understanding the relationship between tables in a database. This is often visualized via an entity-relationship diagram:\n\nEach rectangle represent a table, and within each table are the columns (fields). I am only showing a subset of the columns based on what we have explored so far in class. The connecting lines shows that there are shared values between tables in those columns, which helps one navigate between tables:\n\nIn the person table, the elements of the column person_id overlaps with the elements of person_id column in in the table procedure_occurrence.\nIn the procedure_occurrence table, the elements of the column procedure_concept_id overlaps with the elements of concept_id column in the table concepts.\n\nWe should consider to what degree the values overlap:\n\nFor each person_id in the person table, there may be duplicated person_ids in procedure_occurrence table, as a patient can have multiple procedures. This is a one-to-many relationship.\nMultiple elements of procedure_concept_id in the procedure_occurrence table may correspond to a single element of concept_id in the “concept” table. This is a many-to-one relationship.\nYou can also have a one-to-one relationship.\n\nThe database we’ve been using has been rigorously modeled using a data model called OMOP CDM (Common Data Model). OMOP is short for Observational Medical Outcomes Partnership, and it is designed to be a database format that standardizes data from systems into a format that can be combined with other systems to compare health outcomes across organizations. The full OMOP entity relationship diagram can be found here.\nNow, let’s join some tables.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#join",
    "href": "week2.html#join",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.4 JOIN\n",
    "text": "3.4 JOIN\n\nWe use the JOIN clause when we want to combine information from two tables. Here we are going to combine information from two tables: person and procedure_occurrence.\nTo set the stage, let’s show two tables, x and y. We want to join them by the keys, which are represented by colored boxes in both of the tables.\nNote that table x has a key (“3”) that isn’t in table y, and that table y has a key (“4”) that isn’t in table x.\n\nWe are going to explore INNER JOIN first. In an INNER JOIN, we pick out a column from each table in which its elements are going to be matched. In this case, we only retain rows that have elements that exist in both the x and y tables. We drop all rows that don’t have matches in both tables.\nThere are other types of joins when we want to retain information from the x table or the y table, or both.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#inner-join-syntax",
    "href": "week2.html#inner-join-syntax",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.5 INNER JOIN syntax",
    "text": "3.5 INNER JOIN syntax\nHere’s an example where we are joining person with procedure_occurrence:\n\nSELECT person.person_id, procedure_occurrence.procedure_occurrence_id \n    FROM person\n    INNER JOIN procedure_occurrence\n    ON person.person_id = procedure_occurrence.person_id\n\n\nDisplaying records 1 - 10\n\nperson_id\nprocedure_occurrence_id\n\n\n\n343\n3554\n\n\n357\n3741\n\n\n399\n3928\n\n\n406\n4115\n\n\n411\n4302\n\n\n430\n4489\n\n\n442\n4676\n\n\n453\n4863\n\n\n469\n5050\n\n\n488\n5237\n\n\n\n\n\nWhat’s going on here? The magic happens with this clause, which we use to specify the two tables we need to join.\nFROM person\n  INNER JOIN procedure_occurrence\nThe last thing to note is the ON statement. These are the conditions by which we merge rows. We are taking one column in person, the person_id, and matching the rows up with those rows in procedure_occurrence’s own person_id column:\nON person.person_id = procedure_occurrence.person_id",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#aliases",
    "href": "week2.html#aliases",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.6 Aliases",
    "text": "3.6 Aliases\nAs your queries get more complex, and as you involve more and more tables, you will need to use aliases. I think of them like “nicknames” - they can save you a lot of typing.\nHere is the same query using aliases. We use p as an alias for person and po as an alias for procedure_occurrence. You can see it is a little more compact.\n\nSELECT p.person_id, po.procedure_occurrence_id \n    FROM person AS p\n    INNER JOIN procedure_occurrence AS po\n    ON p.person_id = po.person_id\n\n\nDisplaying records 1 - 10\n\nperson_id\nprocedure_occurrence_id\n\n\n\n343\n3554\n\n\n357\n3741\n\n\n399\n3928\n\n\n406\n4115\n\n\n411\n4302\n\n\n430\n4489\n\n\n442\n4676\n\n\n453\n4863\n\n\n469\n5050\n\n\n488\n5237\n\n\n\n\n\n\n3.6.1 Another example\nHere, I use table aliasing in two different places: in my COUNT, and in my WHERE:\n\nSELECT COUNT(p.person_id)\n  FROM person AS p\n  WHERE p.year_of_birth &lt; 2000;\n\n\n1 records\n\ncount(p.person_id)\n\n\n2694\n\n\n\n\nSome people don’t use AS, just putting the aliases next to the original name:\n\nSELECT COUNT(p.person_id)\n  FROM person p\n  WHERE p.year_of_birth &lt; 2000;\n\n\n1 records\n\ncount(p.person_id)\n\n\n2694\n\n\n\n\nWe can also rename variables using AS:\n\nSELECT COUNT(person_id) AS person_count\n  FROM person \n  WHERE year_of_birth &lt; 2000;\n\n\n1 records\n\nperson_count\n\n\n2694",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#left-join",
    "href": "week2.html#left-join",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.7 LEFT JOIN\n",
    "text": "3.7 LEFT JOIN\n\nJargon alert: The table to the left of the JOIN clause is called the left table, and the table to the right of the JOIN clause is known as the right table. This will become more important as we explore the different join types.\nFROM procedure_occurrence INNER JOIN concept\n      ^^Left Table                    ^^Right Table\nWhat if we want to retain all of the rows in the procedure_occurrence table, even if there are no matches in the concept table? We can use a LEFT JOIN to do that.\n\nIf a row exists in the left table, but not the right table, it will be replicated in the joined table, but have rows with NULL columns from the right table.\nHere is another example:\nWe can see the difference between a INNER JOIN and LEFT JOIN by counting the number of rows kept after joining:\n\nSELECT COUNT (*)\n    FROM person as p\n    INNER JOIN procedure_occurrence as po\n    ON p.person_id = po.person_id\n\n\n1 records\n\ncount_star()\n\n\n37409\n\n\n\n\n\nSELECT COUNT (*)\n    FROM person as p\n    LEFT JOIN procedure_occurrence as po\n    ON p.person_id = po.person_id\n\n\n1 records\n\ncount_star()\n\n\n37510\n\n\n\n\nThis suggests that there are some unique person_ids in person table not found in the person_id of procedure_occurrence table.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#other-kinds-of-joins",
    "href": "week2.html#other-kinds-of-joins",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.8 Other kinds of JOINs",
    "text": "3.8 Other kinds of JOINs\n\nThe RIGHT JOIN is identical to LEFT JOIN, except that the rows preserved are from the right table.\nThe FULL JOIN retains all rows in both tables, regardless if there is a key match.\n\nANTI JOIN is helpful to find all of the keys that are in the left table, but not the right table",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#multiple-joins-with-multiple-tables",
    "href": "week2.html#multiple-joins-with-multiple-tables",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.9 Multiple JOINs with Multiple Tables",
    "text": "3.9 Multiple JOINs with Multiple Tables\n\nSuppose that we want a table with person.person_id, procedure_occurrence.procedure_occurrence_id, and concept.concept_name. Looks like we need a triple join!\nThe way I think of these multi-table joins is to decompose them into two joins:\n\nWe first INNER JOIN person and procedure_occurrence, to produce an output table\nWe take this output table and INNER JOIN it with concept.\n\nGive a try yourself:\n\nSELECT person.person_id, procedure_occurrence.procedure_occurrence_id\n  FROM \n  INNER JOIN \n  ON \n\nThen, add the third join:\n\nSELECT person.person_id, procedure_occurrence.procedure_occurrence_id, concept.concept_name\n  FROM \n  INNER JOIN \n  ON \n  INNER JOIN\n  ON \n\nSome tips: Notice that both of these JOINs have separate ON statements. For the first join, we could have:\nINNER JOIN procedure_occurrence AS po\n  ON p.person_id = po.person_id\nFor the second JOIN, we could have:\nINNER JOIN concept AS c\nON po.procedure_concept_id = c.concept_id\nAnd that gives us the final table, which takes variables from all three tables.\nOne thing to keep in mind is that JOINs are not necessarily commutative; that is, the order of joins can matter. This is because we may drop or preserve rows depending on the JOIN.\nFor combining INNER JOINs, we are looking for the subset of keys that exist in each table, so join order doesn’t matter. But for combining LEFT JOINs and RIGHT JOINS, order can matter.\nIt’s really important to check intermediate output and make sure that you are retaining the rows that you need in the final output. For example, I’d try the first join first and see that it contains the rows that I need before adding the second join.\nHere is the solution:\n\nSELECT p.person_id, po.procedure_occurrence_id, c.concept_name\n  FROM person AS p\n  INNER JOIN procedure_occurrence AS po\n  ON p.person_id = po.person_id\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n\n\nDisplaying records 1 - 10\n\nperson_id\nprocedure_occurrence_id\nconcept_name\n\n\n\n343\n3554\nSubcutaneous immunotherapy\n\n\n357\n3741\nSubcutaneous immunotherapy\n\n\n399\n3928\nSubcutaneous immunotherapy\n\n\n406\n4115\nSubcutaneous immunotherapy\n\n\n411\n4302\nSubcutaneous immunotherapy\n\n\n430\n4489\nPlain X-ray of clavicle\n\n\n442\n4676\nSubcutaneous immunotherapy\n\n\n453\n4863\nCognitive and behavioral therapy\n\n\n469\n5050\nCognitive and behavioral therapy\n\n\n488\n5237\nSputum examination",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#using-join-with-where",
    "href": "week2.html#using-join-with-where",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.10 Using JOIN with WHERE\n",
    "text": "3.10 Using JOIN with WHERE\n\nWhere we really start to cook with gas is when we combine JOIN with WHERE. Let’s add an additional WHERE where we only want those rows that have the concept_name of ’Subcutaneous immunotherapy`:\n\nSELECT p.person_id, po.procedure_occurrence_id, c.concept_name\n  FROM person AS p\n  INNER JOIN procedure_occurrence AS po\n  ON p.person_id = po.person_id\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  WHERE c.concept_name = 'Subcutaneous immunotherapy';\n    \n\n\nDisplaying records 1 - 10\n\nperson_id\nprocedure_occurrence_id\nconcept_name\n\n\n\n16\n289\nSubcutaneous immunotherapy\n\n\n180\n1958\nSubcutaneous immunotherapy\n\n\n9\n187\nSubcutaneous immunotherapy\n\n\n5\n119\nSubcutaneous immunotherapy\n\n\n36\n559\nSubcutaneous immunotherapy\n\n\n124\n1226\nSubcutaneous immunotherapy\n\n\n225\n2244\nSubcutaneous immunotherapy\n\n\n409\n4243\nSubcutaneous immunotherapy\n\n\n236\n2392\nSubcutaneous immunotherapy\n\n\n260\n2556\nSubcutaneous immunotherapy\n\n\n\n\n\nOr keeping rows where the year of birth is before 1980:\n\nSELECT p.person_id, p.year_of_birth, po.procedure_occurrence_id, c.concept_name\n  FROM person AS p\n  INNER JOIN procedure_occurrence AS po\n  ON p.person_id = po.person_id\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n    WHERE p.year_of_birth &lt; 1980;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\nperson_id\nyear_of_birth\nprocedure_occurrence_id\nconcept_name\n\n\n\n343\n1970\n3554\nSubcutaneous immunotherapy\n\n\n357\n1954\n3741\nSubcutaneous immunotherapy\n\n\n399\n1955\n3928\nSubcutaneous immunotherapy\n\n\n406\n1952\n4115\nSubcutaneous immunotherapy\n\n\n411\n1959\n4302\nSubcutaneous immunotherapy\n\n\n430\n1931\n4489\nPlain X-ray of clavicle\n\n\n442\n1947\n4676\nSubcutaneous immunotherapy\n\n\n453\n1970\n4863\nCognitive and behavioral therapy\n\n\n469\n1935\n5050\nCognitive and behavioral therapy\n\n\n488\n1954\n5237\nSputum examination",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#where-vs-on",
    "href": "week2.html#where-vs-on",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.11 WHERE vs ON\n",
    "text": "3.11 WHERE vs ON\n\nYou will see variations of SQL statements that eliminate JOIN and ON entirely, putting everything in WHERE:\n\nSELECT po.person_id, c.concept_name \n    FROM procedure_occurrence as po, concept as c\n    WHERE c.concept_name = 'Subcutaneous immunotherapy'\n    AND po.procedure_concept_id = c.concept_id\n    LIMIT 10;\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\n\n\n\n343\nSubcutaneous immunotherapy\n\n\n357\nSubcutaneous immunotherapy\n\n\n399\nSubcutaneous immunotherapy\n\n\n406\nSubcutaneous immunotherapy\n\n\n411\nSubcutaneous immunotherapy\n\n\n442\nSubcutaneous immunotherapy\n\n\n499\nSubcutaneous immunotherapy\n\n\n533\nSubcutaneous immunotherapy\n\n\n563\nSubcutaneous immunotherapy\n\n\n680\nSubcutaneous immunotherapy\n\n\n\n\n\nI’m not the biggest fan of this, because it is often not clear what is a filtering clause and what is a joining clause, so I prefer to use JOIN/ON with a WHERE.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#revisiting-where-and-versus-or",
    "href": "week2.html#revisiting-where-and-versus-or",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.12 Revisiting WHERE: AND versus OR\n",
    "text": "3.12 Revisiting WHERE: AND versus OR\n\nRevisiting WHERE, we can combine conditions with AND or OR.\nAND is always going to be more restrictive than OR, because our rows must meet two conditions.\n\nSELECT COUNT(*)\n  FROM person\n  WHERE year_of_birth &lt; 1980 \n  AND gender_source_value = 'M'\n\n\n1 records\n\ncount_star()\n\n\n1261\n\n\n\n\nOn the other hand OR is more permissive than AND, because our rows must meet only one of the conditions.\n\nSELECT COUNT(*)\n  FROM person\n  WHERE year_of_birth &lt; 1980 \n  OR gender_source_value = 'M'\n\n\n1 records\n\ncount_star()\n\n\n2629\n\n\n\n\nThere is also NOT, where one condition must be true, and the other must be false.\n\nSELECT COUNT(*)\n  FROM person\n  WHERE year_of_birth &lt; 1980 \n  AND NOT gender_source_value = 'M'\n\n\n1 records\n\ncount_star()\n\n\n1308",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#order-by",
    "href": "week2.html#order-by",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.13 ORDER BY\n",
    "text": "3.13 ORDER BY\n\nORDER BY lets us sort tables by one or more columns:\n\nSELECT p.person_id, po.procedure_occurrence_id, po.procedure_date\n    FROM person as p\n    INNER JOIN procedure_occurrence as po\n    ON p.person_id = po.person_id\n    ORDER BY p.person_id;\n\n\nDisplaying records 1 - 10\n\nperson_id\nprocedure_occurrence_id\nprocedure_date\n\n\n\n1\n1\n1981-08-17\n\n\n1\n2\n1982-09-11\n\n\n1\n3\n1981-08-10\n\n\n1\n4\n1958-03-11\n\n\n1\n5\n1958-03-11\n\n\n2\n6\n1955-10-22\n\n\n2\n7\n1977-04-08\n\n\n2\n8\n1931-09-03\n\n\n2\n9\n2007-09-04\n\n\n2\n10\n1924-01-12\n\n\n\n\n\nOnce we sorted by person_id, we see that for every unique person_id, there can be multiple procedures! This suggests that there is a one-to-many relationship between person and procedure_occurrence tables.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#try-it-out",
    "href": "week2.html#try-it-out",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.14 Try it Out",
    "text": "3.14 Try it Out\nWe can ORDER BY multiple columns at once. Try ordering by p.patient_id and po.procedure_date:\n\nSELECT p.person_id, po.procedure_occurrence_id, po.procedure_date\n    FROM person as p\n    INNER JOIN procedure_occurrence as po\n    ON p.person_id = po.person_id\n    ORDER BY ----, ----",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#constraints-and-rules-for-databases",
    "href": "week2.html#constraints-and-rules-for-databases",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.15 Constraints and rules for Databases",
    "text": "3.15 Constraints and rules for Databases\nSo far, we’ve only queried data, but not added data to databases.\nAs we’ve stated before, DuckDB is an Analytical database, not a Transactional one. That means it prioritizes reading from data tables rather than inserting into them. Transactional databases, on the other hand, can handle multiple inserts from multiple users at once. They are made for concurrent transactions.\nWe are not going to look at how to add to a database in this course, but we are going to examine what the constraints can be placed on a database, because this gives rules on what is allowed in our database to be queried.\nWhen one sets up a database, we also set up the constraints via a Data Definition Language for our tables:\nCREATE TABLE @cdmDatabaseSchema.PERSON (\n            person_id integer NOT NULL,\n            gender_concept_id integer NOT NULL,\n            year_of_birth integer NOT NULL,\n            month_of_birth integer NULL,\n            day_of_birth integer NULL,\n            birth_datetime TIMESTAMP NULL,\n            race_concept_id integer NOT NULL,\n            ethnicity_concept_id integer NOT NULL,\n            location_id integer NULL,\n            provider_id integer NULL,\n            care_site_id integer NULL,\n            person_source_value varchar(50) NULL,\n            gender_source_value varchar(50) NULL,\n            gender_source_concept_id integer NULL,\n            race_source_value varchar(50) NULL,\n            race_source_concept_id integer NULL,\n            ethnicity_source_value varchar(50) NULL,\n            ethnicity_source_concept_id integer NULL );\nWe’ve encountered one constraint: database fields (columns) need to be typed. For example, id keys are usually INTEGER. Names are often VARCHAR.\nHere are some other constraints that can be applied to a field (column):\n\n\nNOT NULL - no values can have a NULL value.\n\nUNIQUE - all values must be unique.\n\nPRIMARY KEY - NOT NULL and UNIQUE.\n\nFOREIGN KEY - value must exist as a primary key in another table’s field. The referenced table’s field must be specified.\n\nCHECK - check the data type and conditions. One example would be our data shouldn’t be before 1900.\n\nDEFAULT - default values are given if not provided.\n\nThe most important constraints to know about are PRIMARY KEY and FOREIGN KEY. A PRIMARY KEY is required for any table, and cannot be NULL and must be unique. This gives an unique id for each entry of the table.\nWhen we create tables in our database, we need to specify which column is a PRIMARY KEY:\nCREATE TABLE person (\n  person_id INTEGER PRIMARY KEY\n)\nFOREIGN KEY involves two or more tables. If a column is declared a FOREIGN KEY, then that key value must exist in a REFERENCES table as a primary key. Here, when we create procedure_occurrence, person_id column REFERENCES the table person’s person_id primay key column, and procedure_concept_id column REFERENCES the table concept’s concept_id primary key column.\nCREATE TABLE procedure_occurrence {\n  procedure_occurrence_id PRIMARY KEY,\n  person_id INTEGER REFERENCES person(person_id)\n  procedure_concept_id INTEGER REFERENCES concept(concept_id)\n}\nThus, we can use constraints to make sure that our database retains its integrity when we add rows to it.\nYou can see an example of constraints for our database here: https://github.com/OHDSI/CommonDataModel/blob/v5.4.0/inst/ddl/5.4/postgresql/OMOPCDM_postgresql_5.4_constraints.sql.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#always-close-the-connection",
    "href": "week2.html#always-close-the-connection",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.16 Always close the connection",
    "text": "3.16 Always close the connection\nWhen we’re done, it’s best to close the connection with dbDisconnect().\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#references",
    "href": "week2.html#references",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.17 References",
    "text": "3.17 References\n\n\nTidyexplain - All JOIN animations come from here.\n\nUnderstanding Joins - another nice visual explanation from R for Data Science.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week3.html",
    "href": "week3.html",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "",
    "text": "4.1 Connecting to our database\nLet’s connect to our database.\nlibrary(duckdb)\n\nLoading required package: DBI\n\nlibrary(DBI)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4          ✔ readr     2.1.5     \n✔ forcats   1.0.1          ✔ stringr   1.5.2     \n✔ ggplot2   4.0.0.9000     ✔ tibble    3.3.0     \n✔ lubridate 1.9.4          ✔ tidyr     1.3.1     \n✔ purrr     1.2.0          \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), \n                      \"data/GiBleed_5.3_1.1.duckdb\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#group-by",
    "href": "week3.html#group-by",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.2 GROUP BY\n",
    "text": "4.2 GROUP BY\n\nSay we want to count, calculate totals, or averages for a particular column by a particular grouping variable. For example, suppose we want to group gender_source_value column in the person table and count the number of person_ids for each value of gender_source_value. We can use a SELECT/GROUP BY pattern to do this.\nThere are some requirements to using SELECT/GROUP BY:\n\nGrouping variable should be categorical (such as c.concept_name)\nGrouping variable must be in SELECT clause (c.concept_name)\n\nCount the number of persons by gender_source_value:\n\nSELECT gender_source_value, COUNT(person_id) AS person_count\n  FROM person\n  GROUP BY gender_source_value\n\n\n2 records\n\ngender_source_value\nperson_count\n\n\n\nF\n1373\n\n\nM\n1321\n\n\n\n\n\nNotice that we use the AS alias to rename COUNT(person_id) to person_count in the column name.\nWe summarize our column in other ways besides COUNT:\n\nMEAN\nMIN\nMAX\nMEDIAN\n\nFor example, we can look at the minimum year_of_birth for each gender in the person table:\n\nSELECT gender_source_value, MIN(year_of_birth)\n FROM person\n GROUP BY gender_source_value\n\n\n2 records\n\ngender_source_value\nmin(year_of_birth)\n\n\n\nF\n1908\n\n\nM\n1909\n\n\n\n\n\n\n4.2.1 Check on Learning\nIf we look at concept table, we notice that there are groups of concepts organized by the domain_id column:\n\nSELECT concept_id, concept_name, domain_id, vocabulary_id\n  FROM concept\n  LIMIT 10\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\nconcept_id\nconcept_name\ndomain_id\nvocabulary_id\n\n\n\n35208414\nGastrointestinal hemorrhage, unspecified\nCondition\nICD10CM\n\n\n1118088\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\nRxNorm\n\n\n40213201\npneumococcal polysaccharide vaccine, 23 valent\nDrug\nCVX\n\n\n1557272\nAlendronate\nDrug\nRxNorm\n\n\n4336464\nCoronary artery bypass graft\nProcedure\nSNOMED\n\n\n4295880\nIntramuscular injection\nProcedure\nSNOMED\n\n\n3020630\nProtein serum/plasma\nMeasurement\nLOINC\n\n\n19129655\nAmpicillin 100 MG/ML Injectable Solution\nDrug\nRxNorm\n\n\n44923712\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\nNDC\n\n\n1569708\nOther diseases of digestive system\nCondition\nICD10CM\n\n\n\n\n\nCOUNT the number of concept_ids grouped by domain_id in the concept table:\n\nSELECT domain_id, COUNT(------) AS count_domain\n  FROM concept\n  GROUP BY -------\n  ORDER BY count_domain DESC\n\nYou can also group by multiple variables. What happens if you group by domain_id and vocabulary_id?",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#group-by-with-joins",
    "href": "week3.html#group-by-with-joins",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.3 GROUP BY with JOINs",
    "text": "4.3 GROUP BY with JOINs\nRecall that table procedure_occurrence records the procedures of each person. Suppose that we do a GROUP BY on each procedure_concept_id and count the number of person_ids to understand how many people were treated for each procedure:\n\nSELECT procedure_concept_id, COUNT(person_id) AS person_count\n  FROM procedure_occurrence\n  GROUP BY procedure_concept_id\n  ORDER BY person_count DESC\n\n\nDisplaying records 1 - 10\n\nprocedure_concept_id\nperson_count\n\n\n\n4107731\n17520\n\n\n4043071\n2820\n\n\n4125906\n2487\n\n\n4170947\n1789\n\n\n4151422\n1659\n\n\n4078793\n1342\n\n\n4035793\n908\n\n\n4295880\n908\n\n\n4191853\n704\n\n\n4195803\n655\n\n\n\n\n\nWe wish we know what the procedure_concept_id referred to. We need to join it with concept table.\nHere, we’re combining SELECT/GROUP_BY with an INNER JOIN:\n\nSELECT c.concept_name AS procedure, COUNT(person_id) AS person_count\n  FROM procedure_occurrence AS po\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  GROUP BY c.concept_name\n  ORDER BY person_count DESC\n\n\nDisplaying records 1 - 10\n\nprocedure\nperson_count\n\n\n\nSubcutaneous immunotherapy\n17520\n\n\nCognitive and behavioral therapy\n2820\n\n\nSuture open wound\n2487\n\n\nBone immobilization\n1789\n\n\nSputum examination\n1659\n\n\nDirect current cardioversion\n1342\n\n\nPulmonary rehabilitation\n908\n\n\nIntramuscular injection\n908\n\n\nAllergy screening test\n704\n\n\nBone density scan\n655\n\n\n\n\n\nEven more complicated: We can group by multiple variables. Here is a triple join where we are counting by both gender_source_value and concept_name:\n\nSELECT c.concept_name AS procedure, p.gender_source_value, COUNT(p.person_id) AS person_count\n  FROM procedure_occurrence AS po\n  INNER JOIN person AS p\n  ON p.person_id = po.person_id\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  GROUP BY c.concept_name, p.gender_source_value\n  ORDER BY person_count DESC\n\n\nDisplaying records 1 - 10\n\nprocedure\ngender_source_value\nperson_count\n\n\n\nSubcutaneous immunotherapy\nF\n9480\n\n\nSubcutaneous immunotherapy\nM\n8040\n\n\nCognitive and behavioral therapy\nM\n1872\n\n\nSuture open wound\nF\n1293\n\n\nSuture open wound\nM\n1194\n\n\nCognitive and behavioral therapy\nF\n948\n\n\nBone immobilization\nF\n933\n\n\nIntramuscular injection\nF\n908\n\n\nBone immobilization\nM\n856\n\n\nSputum examination\nM\n841",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#having",
    "href": "week3.html#having",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.4 HAVING\n",
    "text": "4.4 HAVING\n\nWe can filter by these aggregate variables. But we can’t use them in a WHERE clause. There is an additional clause HAVING:\n\nSELECT c.concept_name AS procedure, COUNT(person_id) AS person_count\n  FROM procedure_occurrence AS po\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  GROUP BY c.concept_name\n  HAVING person_count &gt; 500\n  ORDER BY person_count DESC\n\n\nDisplaying records 1 - 10\n\nprocedure\nperson_count\n\n\n\nSubcutaneous immunotherapy\n17520\n\n\nCognitive and behavioral therapy\n2820\n\n\nSuture open wound\n2487\n\n\nBone immobilization\n1789\n\n\nSputum examination\n1659\n\n\nDirect current cardioversion\n1342\n\n\nIntramuscular injection\n908\n\n\nPulmonary rehabilitation\n908\n\n\nAllergy screening test\n704\n\n\nBone density scan\n655\n\n\n\n\n\nWhy can’t we use WHERE?\nWell, it turns out that SQL clauses have different priorities, which tells the engine how to order the clauses to execute as your queries become bigger. The WHERE clause has higher priority than the GROUP BY clause, which means if you had written WHERE person_count &gt; 500, it would be evaluated before GROUP BY, thus it has no idea person_count exists and throws an error. Here is the full list of SQL clause priorities:\n\n\n\n\n\n\n\nPriority\nClause\nPurpose\n\n\n\n1\nFROM\nChoose tables to query and specify how to JOIN them together\n\n\n2\nWHERE\nFilter tables based on criteria\n\n\n3\nGROUP BY\nAggregates the Data\n\n\n4\nHAVING\nFilters Aggregated Data\n\n\n5\nSELECT\nSelects columns in table and calculate new columns\n\n\n6\nORDER BY\nSorts by a database field\n\n\n7\nLIMIT\nLimits the number of records returned\n\n\n\nIn general, you need to put WHERE to do any filtering before running GROUP BY. Then, after the data is grouped and aggregrated, you can do additional filtereing on the aggregated data via HAVING. Your SQL statement will not work if you put WHERE after GROUP BY / HAVING.\nHere is an example of using both WHERE and HAVING:\n\nSELECT domain_id, COUNT(concept_id) AS count_domain\n  FROM concept\n  WHERE domain_id != 'Drug'\n  GROUP BY domain_id\n  HAVING count_domain &gt; 40\n  ORDER BY count_domain DESC\n\n\n3 records\n\ndomain_id\ncount_domain\n\n\n\nCondition\n86\n\n\nMeasurement\n59\n\n\nProcedure\n54\n\n\n\n\n\nHere’s what happens when you put WHERE after GROUP BY/HAVING. Can you fix it?\n\nSELECT domain_id, COUNT(concept_id) AS count_domain\n  FROM concept\n  GROUP BY domain_id\n  HAVING count_domain &gt; 40\n  WHERE domain_id != 'Drug'\n  ORDER BY count_domain DESC\n\nHere is WHERE/GROUP BY/HAVING combined with an INNER JOIN:\n\nSELECT c.concept_name AS procedure, COUNT(person_id) AS person_count\n  FROM procedure_occurrence AS po\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  WHERE date_part('YEAR', po.procedure_datetime) &gt; 2000\n  GROUP BY c.concept_name\n  HAVING person_count &gt; 500\n  ORDER BY person_count DESC\n\n\n4 records\n\nprocedure\nperson_count\n\n\n\nDirect current cardioversion\n1031\n\n\nSubcutaneous immunotherapy\n705\n\n\nSuture open wound\n697\n\n\nPulmonary rehabilitation\n611\n\n\n\n\n\n\n4.4.1 Check on learning\nSuppose we were given this join, with the column year extracted from procedure_datatime.\n\nSELECT date_part('YEAR', po.procedure_datetime) AS year, person_id, procedure_occurrence_id\n  FROM procedure_occurrence AS po\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n\n\nDisplaying records 1 - 10\n\nyear\nperson_id\nprocedure_occurrence_id\n\n\n\n1992\n343\n3554\n\n\n1990\n357\n3741\n\n\n1991\n399\n3928\n\n\n1990\n406\n4115\n\n\n1992\n411\n4302\n\n\n1938\n430\n4489\n\n\n1992\n442\n4676\n\n\n1984\n453\n4863\n\n\n1948\n469\n5050\n\n\n1962\n488\n5237\n\n\n\n\n\nBuild on top of this query: Group by year, and then aggregate by the COUNT of person_id. Finally, filter it so that the year is higher than 1990. Should you be using WHERE or HAVING?\n\nSELECT date_part('YEAR', po.procedure_datetime) AS year, person_id \n  FROM procedure_occurrence AS po\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#inlike",
    "href": "week3.html#inlike",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.5 IN/LIKE\n",
    "text": "4.5 IN/LIKE\n\nA couple of twists to WHERE. We can use IN to search on multiple conditions. We put the multiple words in a () separated by commas:\n\nSELECT concept_name, domain_id \n  FROM concept\n  WHERE domain_id IN ('Drug', 'Condition')\n\n\nDisplaying records 1 - 10\n\nconcept_name\ndomain_id\n\n\n\nGastrointestinal hemorrhage, unspecified\nCondition\n\n\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\n\n\npneumococcal polysaccharide vaccine, 23 valent\nDrug\n\n\nAlendronate\nDrug\n\n\nAmpicillin 100 MG/ML Injectable Solution\nDrug\n\n\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\n\n\nOther diseases of digestive system\nCondition\n\n\nrotavirus, live, monovalent vaccine\nDrug\n\n\nMidazolam\nDrug\n\n\nEscherichia coli urinary tract infection\nCondition\n\n\n\n\n\nWe can use NOT with IN to exclude a list of conditions:\n\nSELECT concept_name, domain_id \n  FROM concept\n  WHERE domain_id NOT IN ('Drug', 'Condition')\n\n\nDisplaying records 1 - 10\n\nconcept_name\ndomain_id\n\n\n\nCoronary artery bypass graft\nProcedure\n\n\nIntramuscular injection\nProcedure\n\n\nProtein serum/plasma\nMeasurement\n\n\nSurgical manipulation of shoulder joint\nProcedure\n\n\nNeonatal screening\nProcedure\n\n\nHoney bee IgE Ab [Units/volume] in Serum\nMeasurement\n\n\nErythrocyte distribution width [Ratio]\nMeasurement\n\n\nRemoval of subcutaneous contraceptive\nProcedure\n\n\nCladosporium herbarum IgE Ab [Units/volume] in Serum\nMeasurement\n\n\nCommon Ragweed IgE Ab [Units/volume] in Serum\nMeasurement\n\n\n\n\n\nOne note. It is usually faster to make a temporary table with your values and join on that temporary table. We’ll talk more about this below.\nLIKE is one way to do wild card searches.\n\nSELECT concept_name, domain_id \n  FROM concept\n  WHERE domain_id LIKE 'Dru%'\n\n\nDisplaying records 1 - 10\n\n\n\n\n\nconcept_name\ndomain_id\n\n\n\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\n\n\npneumococcal polysaccharide vaccine, 23 valent\nDrug\n\n\nAlendronate\nDrug\n\n\nAmpicillin 100 MG/ML Injectable Solution\nDrug\n\n\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\n\n\nrotavirus, live, monovalent vaccine\nDrug\n\n\nMidazolam\nDrug\n\n\nDiclofenac Sodium 75 MG Delayed Release Oral Tablet\nDrug\n\n\nDiclofenac Sodium 75 MG Delayed Release Oral Tablet\nDrug\n\n\ntetanus and diphtheria toxoids, adsorbed, preservative free, for adult use\nDrug\n\n\n\n\n\nYou can find more informaiton about pattern matching here.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#creating-temporary-tables",
    "href": "week3.html#creating-temporary-tables",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.6 Creating Temporary Tables",
    "text": "4.6 Creating Temporary Tables\nTemporary tables can be very useful for storing intermediate results.\nTemporary tables only last for the session - they disappear after you disconnect, so don’t use them for permanent storage.\nYou can use CREATE OR REPLACE TEMPORARY TABLE clause, followed by your temporary table name and AS, and then give a query of choice:\n\nCREATE OR REPLACE TEMPORARY TABLE temp_person AS\nSELECT person_id, gender_source_value\n  FROM person\n\nYou can also use CREATE TEMPORARY TABLE clause, but it will give you an error if the temporary table has been created already.\nWe can also load in a spreadsheet as a temporary table. Suppose we want to load in the following:\n\nread_csv(\"data/temp_cost.csv\")\n\nRows: 51 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): concept_name\ndbl (2): procedure_concept_id, cost\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 51 × 3\n   concept_name                          procedure_concept_id  cost\n   &lt;chr&gt;                                                &lt;dbl&gt; &lt;dbl&gt;\n 1 Cognitive and behavioral therapy                   4043071  3300\n 2 Nasal sinus endoscopy                              4010253  3000\n 3 Intubation                                         4202832  4000\n 4 Removal of subcutaneous contraceptive              4199276  1800\n 5 Radiography of humerus                             4047491  2300\n 6 Radiologic examination of knee                     4252419  4100\n 7 Lung volume reduction surgery                      4323902   730\n 8 Sputum examination                                 4151422  4000\n 9 Percutaneous coronary intervention                 4216130  1800\n10 Injection of epinephrine                           4197460  2600\n# ℹ 41 more rows\n\n\nThen we can use COPY from DuckDB to load it in:\n\nCREATE OR REPLACE TEMP TABLE cost(\n  concept_name VARCHAR,\n  procedure_concept_id INT,\n  cost INT\n);\nCOPY cost FROM 'data/temp_cost.csv'\n\nDuckDB also is smart enough to infer the column types and names from the data:\n\nCREATE OR REPLACE TEMP TABLE cost AS\n  SELECT * FROM read_csv('data/temp_cost.csv')\n\nNow our table exists in our database, and we can work with it.\n\nSELECT * FROM cost\n\n\nDisplaying records 1 - 10\n\nconcept_name\nprocedure_concept_id\ncost\n\n\n\nCognitive and behavioral therapy\n4043071\n3300\n\n\nNasal sinus endoscopy\n4010253\n3000\n\n\nIntubation\n4202832\n4000\n\n\nRemoval of subcutaneous contraceptive\n4199276\n1800\n\n\nRadiography of humerus\n4047491\n2300\n\n\nRadiologic examination of knee\n4252419\n4100\n\n\nLung volume reduction surgery\n4323902\n730\n\n\nSputum examination\n4151422\n4000\n\n\nPercutaneous coronary intervention\n4216130\n1800\n\n\nInjection of epinephrine\n4197460\n2600\n\n\n\n\n\nNow we can merge our temporary cost table with procedure_occurrence and calculate the sum cost per year:\n\nSELECT date_part('YEAR', po.procedure_datetime) AS year, SUM(cost) AS sum_cost_month\n  FROM procedure_occurrence AS po\n  INNER JOIN cost AS c\n  ON po.procedure_concept_id = c.procedure_concept_id\n  GROUP BY year\n  ORDER BY year DESC\n\n\nDisplaying records 1 - 10\n\nyear\nsum_cost_month\n\n\n\n2019\n619380\n\n\n2018\n1271370\n\n\n2017\n1201430\n\n\n2016\n1122680\n\n\n2015\n1079390\n\n\n2014\n1103730\n\n\n2013\n1084430\n\n\n2012\n1118890\n\n\n2011\n1041720\n\n\n2010\n1015700\n\n\n\n\n\nWe’ll talk more about Subqueries and Views next time, which are another options to split queries up.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#data-integrity",
    "href": "week3.html#data-integrity",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.7 Data Integrity",
    "text": "4.7 Data Integrity\nWe talked a little bit last week about database constraints, such as FOREIGN KEY constraints, where we can’t add a row that refers to a foreign key if that foreign key doesn’t exist.\nThese constraints exist to ensure the data integrity of a database. For example, we don’t want to have rows in procedure_occurrence that have procedure_concept_id that don’t exist in the concept table.\nAnother way to keep data integrity is to have all operations be ACID compliant transactions. That is, all operations (inserting and removing rows) needs to be done in full before the next set of transactions (which could come from another user) are done to the database.\nACID is short for:\n\n\nAtomicity - the operation must be all or none\n\nConsistency - the operation must be done the same way\n\nIsolation - the operation is not dependent on other operations, and is done in series, not parallel.\n\nDurability - the operation must be robust to disruptions (like power outages). If a database is interrupted in an update, there must be a rollback mechanism to get the previous version of the data.\n\nFinally, the design of the tables and what information they contain, and how they relate to each other is also important to data integrity. The process of deciding which columns belong to which tables is called normalization.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#database-design",
    "href": "week3.html#database-design",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.8 Database Design",
    "text": "4.8 Database Design\nDatabase design can be difficult because:\n\nYou need to understand the requirements of the data and how it is collected\n\nFor example, when is procedure information collected?\nDo patients have multiple procedures? (Cardinality)\n\n\nYou need to group like data with like (normalization)\n\nData that is dependent on a primary key should stay together\nFor example, person should contain information of a patient such as demographics, but not individual procedure_concept_ids.\n\n\nYou need to have an automated process to add data to the database (Extract Transfer Load, or ETL).\nSearch processes must be optimized for common operations (indexing)\n\nOf this, steps 1 and 2 are the most difficult and take the most time. They require the designer to interview users of the data and those who collect the data to reflect the business processes. These two steps are called the Data Modeling steps.\nThese processes are essential if you are designing a transactional database that is collecting data from multiple sources (such as clinicians at time of care) and is updated multiple times a second.\nIf you want to read more about the data model we’re using, I’ve written up a short bit here: OMOP Data Model.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#database-administration",
    "href": "week3.html#database-administration",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.9 Database Administration",
    "text": "4.9 Database Administration\nMaintaining a database is also known as database administration. Database Admins are responsible for the following:\n\nMaking sure that the data maintains its integrity\nEnsuring that common queries are optimized for fast loading\nGeneral upkeep and optimization. Oftentimes, if multiple people are accessing the data at once, the data may be distributed among multiple machines (load balancing).\nSecurity. We don’t want the wrong people accessing the data.\n\nBeing a good admin does not start from scratch. You can’t be a top-tier admin straight out of school. There are a lot of things DB admins learn, but a lot of the optimization happens from experience with managing the data.\nRespect your DB Admin and know that they know a lot about how to optimize your queries.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#always-close-the-connection",
    "href": "week3.html#always-close-the-connection",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.10 Always close the connection",
    "text": "4.10 Always close the connection\nWhen we’re done, it’s best to close the connection with dbDisconnect().\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week4.html",
    "href": "week4.html",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "",
    "text": "5.1 Connecting to our database\nIn this lecture, we will explore subqueries and views in SQL. These concepts help us break complicated queries into smaller, more manageable parts, improving our ability to read and maintain our code.\nAs always, to access the data, we create our database connection to our data.\nlibrary(duckdb)\nlibrary(DBI)\n\ncon &lt;- DBI::dbConnect(\n  duckdb::duckdb(), \n  \"data/GiBleed_5.3_1.1.duckdb\"\n)\nWith our data loaded and ready to go, let’s get started!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#subqueries",
    "href": "week4.html#subqueries",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.2 Subqueries",
    "text": "5.2 Subqueries\nA subquery is a query nested inside another query. Subqueries let us process smaller computations inside larger outer queries.\nIf we look at this very generic statement of all the queries we learned so far:\nSELECT c2, SUM(c3)\nFROM d1\nWHERE c1 IN (a1, a2, a3, a4)\nINNER JOIN d2\nBY d1.c2 = d2.c2\nGROUP BY c2\nHAVING SUM(c3) IN (z1, z2)\nWhere is it possible to substitute a Subquery? Subquries can be organized by their outputs:\n\nSingle-value Subquery\nSingle-column Subquery\nMulti-column Subquery\n\nWe’re just going to focus on Single-column Subqueries for today.\n\n5.2.1 Using a Subquery in the SELECT Clause\nLet’s use a subquery to dynamically calculate the age of each individual (as of November 7th, 2025) in our database while collecting other patient demographic data. To handle this, we’ll make use of the person table in our dataframe and the birth_datetime column.\n\nSELECT \n  person_id, \n  birth_datetime,\n  gender_source_value, \n  race_source_value, \n  ethnicity_source_value,\n  (SELECT \n    DATE_DIFF('year', birth_datetime, DATE '2024-03-07')\n  ) AS age\nFROM person\nLIMIT 10\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\nperson_id\nbirth_datetime\ngender_source_value\nrace_source_value\nethnicity_source_value\nage\n\n\n\n6\n1963-12-31\nF\nblack\nwest_indian\n61\n\n\n123\n1950-04-12\nM\nwhite\nitalian\n74\n\n\n129\n1974-10-07\nM\nwhite\npolish\n50\n\n\n16\n1971-10-13\nF\nwhite\namerican\n53\n\n\n65\n1967-03-31\nF\nblack\ndominican\n57\n\n\n74\n1972-01-05\nF\nwhite\nenglish\n52\n\n\n42\n1909-11-02\nF\nwhite\nirish\n115\n\n\n187\n1945-07-23\nM\nwhite\nirish\n79\n\n\n18\n1965-11-17\nF\nwhite\nenglish\n59\n\n\n111\n1975-05-02\nF\nwhite\nenglish\n49\n\n\n\n\n\nAs we can see in the above example, we’ve performed the computation of calculating patient age in a subquery:\nSELECT \nDATE_DIFF('year', birth_datetime, DATE '2024-03-07')\nThis subquery is integrated into the larger query of collecting patient data, and doesn’t need to refer to the person table. Any variable referenced in the larger outer query can be accessed in the inner subquery.\n\n5.2.1.1 Using DATEDIFF to compare dates\nThe DATEDIFF function in SQL can be used to calculate differences between days. DATEDIFF takes three parameters: the unit of time, a first date, and a second date. For instance, calling:\nSELECT DATEDIFF('month', DATE '2020-01-01', DATE '2025-11-07')\ncalculates the number of months between January 1st, 2020, and November 11th, 2025. All three parameters are required. You can refer to the documentation for DATEDIFF here to see other options for time intervals.\n\n5.2.1.2 Check on learning\nFill in the blank in the query below to dynamically calculate the number of days between the condition start date and condition end date for all conditions from the condition_occurrence table\n\nSELECT \n  person_id,\n  visit_occurrence_id,\n  condition_occurrence_id,\n  condition_concept_id, \n  condition_start_date,\n  condition_end_date,\n  (SELECT \n    DATE_DIFF(_____, _____, _____)\n  ) AS condition_time_span\nFROM condition_occurrence\nLIMIT 10\n\n\n5.2.2 Filtering with a Subquery\nWe’ve now worked through a couple of examples where we use subqueries to create new variables within our SELECT clause. Another type of query we can tackle is the filtration of data based on conditions calculated in a subquery.\nHere’s a great example from The Data School, where we apply a subquery in the filtration component of our larger query to find individuals on Facebook who have the same number of Facebook connections as anyone else on LinkedIn.\n\n\n5.2.2.1 A brief review: the IN clause\nThe IN clause in SQL is used to filter records where a column matches any value in a specified list or subquery result. It is a shorthand for multiple OR conditions and is commonly used for readability and efficiency.\nFor instance, the basic syntax of:\nSELECT column_name\nFROM table_name\nWHERE column_name IN (value1, value2, value3);\nis equivalent to:\nSELECT column_name\nFROM table_name\nWHERE column_name = value1 \n   OR column_name = value2 \n   OR column_name = value3;\nNow back to using a subquery for filtering!\nFor our own database, let’s collect patient demographic data for all patients who had some kind of procedure performed after December 31st, 2018. We’ll make use of the person and procedure_occurrence tables for this query.\nWe can start by writing the computation for our subquery - collection patient IDs for individuals who had a procedure after December 31st, 2018.\n\nSELECT \n  person_id \nFROM \n  procedure_occurrence\nWHERE \n  procedure_datetime &gt;= DATE '2019-01-01';\n\n\nDisplaying records 1 - 10\n\nperson_id\n\n\n\n636\n\n\n1072\n\n\n1084\n\n\n1072\n\n\n967\n\n\n823\n\n\n823\n\n\n972\n\n\n703\n\n\n299\n\n\n\n\n\nNow, we can insert this query into the WHERE clause of our larger query that collects patient demographic information!\n\nSELECT \n  person_id, \n  birth_datetime, \n  gender_source_value, \n  race_source_value, \n  ethnicity_source_value\nFROM \n  person\nWHERE \n  person_id IN (\n    SELECT \n      person_id \n    FROM \n      procedure_occurrence\n    WHERE \n      procedure_datetime &gt;= DATE '2019-01-01'\n  );\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\nperson_id\nbirth_datetime\ngender_source_value\nrace_source_value\nethnicity_source_value\n\n\n\n160\n1961-07-27\nF\nhispanic\npuerto_rican\n\n\n99\n1958-10-25\nF\nblack\nwest_indian\n\n\n36\n1958-10-21\nF\nwhite\ngerman\n\n\n286\n1928-05-05\nF\nwhite\namerican\n\n\n299\n1961-12-09\nF\nwhite\ngerman\n\n\n403\n1922-02-27\nM\nwhite\npolish\n\n\n280\n1938-10-28\nF\nhispanic\ncentral_american\n\n\n307\n1969-06-21\nM\nwhite\nrussian\n\n\n636\n1948-03-12\nM\nwhite\nirish\n\n\n354\n1956-01-05\nF\nwhite\nirish\n\n\n\n\n\n\n5.2.2.2 Check on learning\nWrite out a query to collection patient IDs for individuals who had at least two procedures. This query will become the subquery in our larger computation.\n\nSELECT person_id, COUNT(person_id) AS person_id_count\nFROM procedure_occurrence\nGROUP BY ---\nHAVING --- &gt;= 2\n\nFor our subquery, we only need person_id as our final column, and not person_id_count. Move the COUNT(person_id) statement into the HAVING clause:\n\nSELECT person_id\nFROM procedure_occurrence\nGROUP BY ---\nHAVING --- &gt;= 2\n\nNow, fill in the blank in the following SQL query with the subquery that you just developed to collect patient demographic data for any patient that had at least two procedures:\n\nSELECT \n  person_id, \n  birth_datetime, \n  gender_source_value, \n  race_source_value, \n  ethnicity_source_value\nFROM \n  person\nWHERE \n  person_id IN (_________);\n\n\n5.2.3 When to use subqueries\nSubqueries are powerful because they allow you to break down complex queries into smaller, more manageable parts. You should use subqueries when:\n\nYou need to use a computed value in a query: See our previous examples!\nYou want to avoid duplicating code: Instead of repeating a calculation, you can use a subquery to define it a single time and reuse it (i.e. age).\nYou want to avoid performing unnecessary JOIN’s: Subqueries let you filter results row-by-row based on information from another table without requiring a JOIN.\nYou need to improve your code’s readability: Subqueries help make queries more modular and easier to debug. Conceptually, it can be easier to create a multi-step query and check intermediate phases than do perform a bunch of JOIN’s.\n\nCan you think of any examples where it might be better to use a JOIN over a subquery?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#views",
    "href": "week4.html#views",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.3 Views",
    "text": "5.3 Views\nA view is a stored SQL query that acts as a virtual table. Views improve code reuse and readability. The following image, taken from SQLShack, depicts how a complicated query can be turned into a customized view that can be used in downstream data processing.\n\n\n5.3.1 When to use views\nSimilar to subqueries, views allow us to organize our data into more modular, accessible, and easy-to-read components. You should use views when:\n\nYou want to simplify complex queries and improve code maintainability: Instead of frequently reusing a complex query, you can store the data generated from the query into a view and access it readily.\nYou want to enhance security and restrict data access to others without authorization: Making your own view can limit access to sensitive columns while still allowing other users to query the necessary data\nYou want to promote data consistency: Performing a calculation in a view ensures that everyone uses the same calculation to grab consistent data (e.g. calculating age of patients)\n\nA view itself does not actually store data like a physical table does. Instead, a view is a saved SQL query that gets executed each time you query the view.\n\n5.3.2 A brief tangent: indexing\nIndexing is a technique used to speed up data retrieval from a database table. An index improves the efficiency of queries by allowing the database to locate rows faster without having to scan the entire table. This is similar to how a table of contents in a book helps you quickly find chapters instead of reading every page.\nHowever, views are not indexed: Since views are virtual tables, they do not store data or have their own indexes. Instead, they rely on the indexes that come from the underlying tables. Because views do not have indexes, querying a view can be slower than querying a physical table. Indeed, since the database recomputes the view's query each time, more complex views can lead to performance issues.\n\n5.3.3 Example: Creating a View\nWith our own data, let’s create a view from the concept table that focuses on the drugs in our dataset.\n\nCREATE VIEW drugs AS\nSELECT * FROM concept\nWHERE domain_id == 'Drug';\n\nNow, we can use this view just like a table:\n\nSELECT * \nFROM drugs\nLIMIT 5;\n\n\n5 records\n\n\n\n\n\n\n\n\n\n\n\n\n\nconcept_id\nconcept_name\ndomain_id\nvocabulary_id\nconcept_class_id\nstandard_concept\nconcept_code\nvalid_start_date\nvalid_end_date\ninvalid_reason\n\n\n\n1118088\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\nRxNorm\nBranded Drug\nS\n213469\n1970-01-01\n2099-12-31\nNA\n\n\n40213201\npneumococcal polysaccharide vaccine, 23 valent\nDrug\nCVX\nCVX\nS\n33\n2008-12-01\n2099-12-31\nNA\n\n\n1557272\nAlendronate\nDrug\nRxNorm\nIngredient\nS\n46041\n1970-01-01\n2099-12-31\nNA\n\n\n19129655\nAmpicillin 100 MG/ML Injectable Solution\nDrug\nRxNorm\nClinical Drug\nS\n789980\n2008-03-30\n2099-12-31\nNA\n\n\n44923712\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\nNDC\n11-digit NDC\nNA\n00025152531\n2000-01-01\n2099-12-31\nNA\n\n\n\n\n\nIf a view already exists in your database, then trying to create a new view with the same name will generate an error! To delete a view from memory, using the DROP VIEW command. E.g.:\nDROP VIEW IF EXISTS drugs;\n\n5.3.3.1 Check on learning\nFill in the blank in the query below to create a view that stores only measurements from the concept table\n\nCREATE VIEW measurements AS\nSELECT * FROM concept\nWHERE domain_id == ________;\n\n\nSELECT *\nFROM measurements\nLIMIT 5;",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#query-optimization",
    "href": "week4.html#query-optimization",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.4 Query Optimization",
    "text": "5.4 Query Optimization\nWhile writing efficient SQL queries is important, database performance optimization is a complex topic that is mostly beyond the scope of “Intro to SQL”. However, here are some key takeaways to keep in mind:\n\nDo not manually create indexes: Indexing can significantly improve query performance, but in most cases, it is the responsibility of the Database Administrator (DBA) to manage indexes appropriately. If you believe an index is needed, consult with your DBA.\nWhen in doubt, talk to your database administrator: Especially when your database is transactional, you should not be the one doing these modifications! DBAs have the expertise to optimize database performance, manage indexing, and ensure efficient query execution. Trust your DBA!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#summary",
    "href": "week4.html#summary",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.5 Summary",
    "text": "5.5 Summary\n\nSubqueries allow us to use the result of one query inside another\nViews provide a way to store and reuse complex queries as virtual tables\nUsing subqueries and views can make SQL queries more modular and maintainable.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#always-close-the-connection",
    "href": "week4.html#always-close-the-connection",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.6 Always close the connection",
    "text": "5.6 Always close the connection\nWhen we’re done, always close the connection with dbDisconnect().\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#references",
    "href": "week4.html#references",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.7 References",
    "text": "5.7 References\n\n\nThe Data School - all SUBQUERY animations come from here\n\nSQL Shack - the image depicting the creation of a VIEW comes from here\n\nW3 Schools - a reference for parameter options for DATEDIFF",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html",
    "href": "miscellaneous.html",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "",
    "text": "6.1 How to Store Passwords\nThis section is for small articles or to answer questions in class.\nA warning: do not store passwords in your code. It is a major security risk.\nThe key to avoiding this is to store the password where your machine can access it, but is not part of your code base. (If you are more advanced, you can store the password in your project directory, but make sure it is in your .gitignore).\nThere are multiple ways to store passwords securely:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#how-to-store-passwords",
    "href": "miscellaneous.html#how-to-store-passwords",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "",
    "text": "Store them as an Environment Variable on your machine\nUse a global .Renviron file to store it outside of your code: https://rstats.wtf/r-startup.html#renviron\nStore them in a secure password manager / keyring (see below).\n\n\n6.1.1 What are environment variables?\nThese are variables that can be seen by all applications, including R/RStudio. They are not stored within code, but as variables in memory. One of the ones you might have had to struggle wiht is JAVA_HOME, whih is where you set a Java installation.\nWe can set environment variables directly, or we can specify them in a file called .Renviron that lives in our home directory.\nWe will use them as a more secure way to store our passwords. We choose the user scope so that it is saved in our home directory, not the project directory. This way, we can protect our password from prying eyes and bots.\n\nusethis::edit_r_environ(scope=\"user\")\n\n☐ Edit '/Users/tladera2/.Renviron'.\n\n\n☐ Restart R for changes to take effect.\n\n\nAdd the following to your .Renviron file:\nCLASS_DB_PASSWORD=\"IntroSQL\"\nYou may have to reopen the project for it to be loaded in your environment variables. We can now load the password using Sys.getenv().\n\nSys.getenv(\"CLASS_DB_PASSWORD\")\n\n[1] \"IntroSQL\"\n\n\nYou can also set the environment variable using Windows Control Panel or PowerShell: https://phoenixnap.com/kb/windows-set-environment-variable - the easiest way to do it is probably the control panel method.\nThere will probably be some sort of authentication process involved in connecting to your databases at Fred Hutch. I’ll add more info when I know more.\nThere is much more about storing passwords and other secrets such as API keys here: https://cran.r-project.org/web/packages/httr/vignettes/secrets.html.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#databases-versus-data-warehouses",
    "href": "miscellaneous.html#databases-versus-data-warehouses",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.2 Databases versus Data Warehouses",
    "text": "6.2 Databases versus Data Warehouses\n\n\n\n\n\ngraph TD\n  A[(Database)] --ETL--&gt; D\n  B[(Database)] --ETL--&gt; D\n  C[(Database)] --ETL--&gt; D\n  D[(Data Warehouse)] \n\n\n\n\n\n\n\n\n\nDatabases: made for data collection, or transactional processing - these systems are made to be updated by multiple sources at once. For example, a collection form that feeds into a database can be submitted by multiple people at once. If you need the latest records, you want to pull from the database.\n\nData Warehouse: Aggregated data from many databases, made for data analysis, or analytical processing. They are usually updated on a nightly basis, taking summary data from each database.\n\nWe will be mostly doing analytical querying, as if our data is stored in a data warehouse.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#whats-the-deal-with-the-semicolon",
    "href": "miscellaneous.html#whats-the-deal-with-the-semicolon",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.3 What’s the deal with the ; (semicolon)?",
    "text": "6.3 What’s the deal with the ; (semicolon)?\nWe use the ; to specify the end of a SQL statement. It is mostly important if you write SQL statements in multiple parts, which we will not do in class.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#keep-in-mind-beware-the-smart-quotes",
    "href": "miscellaneous.html#keep-in-mind-beware-the-smart-quotes",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.4 Keep in Mind: Beware the Smart Quotes",
    "text": "6.4 Keep in Mind: Beware the Smart Quotes\nBeware cutting and pasting code from Microsoft Word\nMicrosoft products such as Word, will transform double quotes \" into what are called smart quotes: “”. This is bad for us, because it breaks our code.\n\"This is the Original String\"\nwill transform into:\n“This is the Original String”\nIt is very hard to see the difference between these, but if you cut and paste the bottom one (from a word document), your code will not run. That’s because the smart quotes aren’t double quotes, which you need to specify a string.\nJust be aware that you might have to fix these quotes if you’re cutting / pasting from a Microsoft product (although google is also guilty of this).\nOftentimes, you can disable this in Word/Google Docs, or be prepared to replace the smart quotes with double quotes. :::",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#dumping-a-query-straight-into-memory",
    "href": "miscellaneous.html#dumping-a-query-straight-into-memory",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.5 Dumping a Query Straight into memory",
    "text": "6.5 Dumping a Query Straight into memory\n\nlibrary(duckdb)\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), \n                      \"data/GiBleed_5.3_1.1.duckdb\")\n\nWe can add a line to our SQL code cell to save the output of our SQL query\n```{sql}\n#| connection: \"con\"\n#| output.var: person\nSELECT * FROM person\n  LIMIT 10;\n```\nIf we run this, we will save the output into the object called person:\n\nSELECT * FROM person\n  LIMIT 10;\n\nWe can work with this as a normal R object now:\n\nperson\n\n   person_id gender_concept_id year_of_birth month_of_birth day_of_birth\n1          6              8532          1963             12           31\n2        123              8507          1950              4           12\n3        129              8507          1974             10            7\n4         16              8532          1971             10           13\n5         65              8532          1967              3           31\n6         74              8532          1972              1            5\n7         42              8532          1909             11            2\n8        187              8507          1945              7           23\n9         18              8532          1965             11           17\n10       111              8532          1975              5            2\n   birth_datetime race_concept_id ethnicity_concept_id location_id provider_id\n1      1963-12-31            8516                    0          NA          NA\n2      1950-04-12            8527                    0          NA          NA\n3      1974-10-07            8527                    0          NA          NA\n4      1971-10-13            8527                    0          NA          NA\n5      1967-03-31            8516                    0          NA          NA\n6      1972-01-05            8527                    0          NA          NA\n7      1909-11-02            8527                    0          NA          NA\n8      1945-07-23            8527                    0          NA          NA\n9      1965-11-17            8527                    0          NA          NA\n10     1975-05-02            8527                    0          NA          NA\n   care_site_id                  person_source_value gender_source_value\n1            NA 001f4a87-70d0-435c-a4b9-1425f6928d33                   F\n2            NA 052d9254-80e8-428f-b8b6-69518b0ef3f3                   M\n3            NA 054d32d5-904f-4df4-846b-8c08d165b4e9                   M\n4            NA 00444703-f2c9-45c9-a247-f6317a43a929                   F\n5            NA 02a3dad9-f9d5-42fb-8074-c16d45b4f5c8                   F\n6            NA 02fbf1be-29b7-4da8-8bbd-14c7433f843f                   F\n7            NA 0177d2e0-98f5-4f3d-bcfd-497b7a07b3f8                   F\n8            NA 07a1e14d-73ed-4d3a-9a39-d729745773fa                   M\n9            NA 0084b0fe-e30f-4930-b6d1-5e1eff4b7dea                   F\n10           NA 0478d6b3-bdb3-4574-9b93-cf448d725b84                   F\n   gender_source_concept_id race_source_value race_source_concept_id\n1                         0             black                      0\n2                         0             white                      0\n3                         0             white                      0\n4                         0             white                      0\n5                         0             black                      0\n6                         0             white                      0\n7                         0             white                      0\n8                         0             white                      0\n9                         0             white                      0\n10                        0             white                      0\n   ethnicity_source_value ethnicity_source_concept_id\n1             west_indian                           0\n2                 italian                           0\n3                  polish                           0\n4                american                           0\n5               dominican                           0\n6                 english                           0\n7                   irish                           0\n8                   irish                           0\n9                 english                           0\n10                english                           0",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#query-plans",
    "href": "miscellaneous.html#query-plans",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.6 Query Plans",
    "text": "6.6 Query Plans\nAll database systems will translate your SQL query into a concrete query plan: this shows step by step, how the engine will execute your query. With DuckDB, we can use EXPLAIN.\nNote that the output of EXPLAIN is not a table, which is why I’m using an R chunk to execute the SQL.\n\nstatement &lt;-   \"EXPLAIN SELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.procedure_date;\"\n\ndbGetQuery(con, statement)\n\nphysical_plan\n┌───────────────────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_decompress_integ│\n│     ral_integer(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│          ~0 rows          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│          ORDER_BY         │\n│    ────────────────────   │\n│   po.procedure_date ASC   │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_compress_integra│\n│     l_usmallint(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│        ~38,448 rows       │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│         person_id         │\n│        concept_name       │\n│       procedure_date      │\n│                           │\n│        ~38,448 rows       │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         HASH_JOIN         │\n│    ────────────────────   │\n│      Join Type: INNER     │\n│                           │\n│        Conditions:        ├──────────────┐\n│   procedure_concept_id =  │              │\n│         concept_id        │              │\n│                           │              │\n│        ~38,448 rows       │              │\n└─────────────┬─────────────┘              │\n┌─────────────┴─────────────┐┌─────────────┴─────────────┐\n│         SEQ_SCAN          ││         SEQ_SCAN          │\n│    ────────────────────   ││    ────────────────────   │\n│           Table:          ││       Table: concept      │\n│    procedure_occurrence   ││   Type: Sequential Scan   │\n│                           ││                           │\n│   Type: Sequential Scan   ││        Projections:       │\n│                           ││         concept_id        │\n│        Projections:       ││        concept_name       │\n│    procedure_concept_id   ││                           │\n│         person_id         ││          Filters:         │\n│       procedure_date      ││  concept_id&gt;=4010253 AND  │\n│                           ││    concept_id&lt;=44805732   │\n│                           ││                           │\n│        ~37,409 rows       ││         ~444 rows         │\n└───────────────────────────┘└───────────────────────────┘\n\n\nUsing EXPLAIN ANALYZE will not only show the query plan, but also how long it takes to execute each step.\n\nstatement &lt;-   \"EXPLAIN ANALYZE SELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.procedure_date;\"\n\ndbGetQuery(con, statement)\n\nanalyzed_plan\n┌─────────────────────────────────────┐\n│┌───────────────────────────────────┐│\n││    Query Profiling Information    ││\n│└───────────────────────────────────┘│\n└─────────────────────────────────────┘\nEXPLAIN ANALYZE SELECT po.person_id, c.concept_name, po.procedure_date     FROM procedure_occurrence as po      INNER JOIN concept as c     ON po.procedure_concept_id = c.concept_id     ORDER BY po.procedure_date;\n┌────────────────────────────────────────────────┐\n│┌──────────────────────────────────────────────┐│\n││              Total Time: 0.0046s             ││\n│└──────────────────────────────────────────────┘│\n└────────────────────────────────────────────────┘\n┌───────────────────────────┐\n│           QUERY           │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│      EXPLAIN_ANALYZE      │\n│    ────────────────────   │\n│           0 rows          │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_decompress_integ│\n│     ral_integer(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│        37,409 rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│          ORDER_BY         │\n│    ────────────────────   │\n│   po.procedure_date ASC   │\n│                           │\n│        37,409 rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_compress_integra│\n│     l_usmallint(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│        37,409 rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│         person_id         │\n│        concept_name       │\n│       procedure_date      │\n│                           │\n│        37,409 rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         HASH_JOIN         │\n│    ────────────────────   │\n│      Join Type: INNER     │\n│                           │\n│        Conditions:        │\n│   procedure_concept_id =  ├──────────────┐\n│         concept_id        │              │\n│                           │              │\n│        37,409 rows        │              │\n│          (0.00s)          │              │\n└─────────────┬─────────────┘              │\n┌─────────────┴─────────────┐┌─────────────┴─────────────┐\n│         TABLE_SCAN        ││         TABLE_SCAN        │\n│    ────────────────────   ││    ────────────────────   │\n│           Table:          ││       Table: concept      │\n│    procedure_occurrence   ││   Type: Sequential Scan   │\n│                           ││                           │\n│   Type: Sequential Scan   ││        Projections:       │\n│                           ││         concept_id        │\n│        Projections:       ││        concept_name       │\n│    procedure_concept_id   ││                           │\n│         person_id         ││          Filters:         │\n│       procedure_date      ││  concept_id&gt;=4010253 AND  │\n│                           ││    concept_id&lt;=44805732   │\n│                           ││                           │\n│        37,409 rows        ││          235 rows         │\n│          (0.00s)          ││          (0.00s)          │\n└───────────────────────────┘└───────────────────────────┘",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#apache-iceberg",
    "href": "miscellaneous.html#apache-iceberg",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.7 Apache Iceberg",
    "text": "6.7 Apache Iceberg\nOne transactional database format that is starting to be very important is Apache Iceberg.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#how-do-we-speed-things-up",
    "href": "miscellaneous.html#how-do-we-speed-things-up",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.8 How do we speed things up?",
    "text": "6.8 How do we speed things up?\nOur main tool for speeding up database searches is Indexing. Creating an index on a column speeds up searching through that particular column.\nDatabase Tuning is as much an art as it is a science. Too many indexes will make the database too big, whereas too few indexes will result in slow performance. This is why we hire database admins. Their work is incredibly important to keeping our data integrity and performing.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#the-omop-data-model",
    "href": "miscellaneous.html#the-omop-data-model",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.9 The OMOP Data Model",
    "text": "6.9 The OMOP Data Model\nThe database we’ve been using has been rigorously modeled using a data model called OMOP CDM (Common Data Model). OMOP is short for Observational Medical Outcomes Partnership, and it is designed to be a database format that standardizes data from systems into a format that can be combined with other systems to compare health outcomes across organizations.\nThis is a huge accomplishment, because there are a lot of different pieces of a healthcare system. Not only that, we need standardized vocabularies, and standardized units so that we are comparing the same things across the healthcare systems.\nThe following figure shows how chronic disesases are treated across (Link to paper) healthcare systems. This could not have been done without converting all of the electronic healthcare data to\n\n\nhttps://link.springer.com/article/10.1007/s10916-018-1076-5\n\nMuch more info about OMOP is here: OMOP Data Standardization.\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "tableref.html",
    "href": "tableref.html",
    "title": "\n7  Table Reference\n",
    "section": "",
    "text": "7.1 person table:\nSELECT * FROM person LIMIT 10;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nperson_id\ngender_concept_id\nyear_of_birth\nmonth_of_birth\nday_of_birth\nbirth_datetime\nrace_concept_id\nethnicity_concept_id\nlocation_id\nprovider_id\ncare_site_id\nperson_source_value\ngender_source_value\ngender_source_concept_id\nrace_source_value\nrace_source_concept_id\nethnicity_source_value\nethnicity_source_concept_id\n\n\n\n6\n8532\n1963\n12\n31\n1963-12-31\n8516\n0\nNA\nNA\nNA\n001f4a87-70d0-435c-a4b9-1425f6928d33\nF\n0\nblack\n0\nwest_indian\n0\n\n\n123\n8507\n1950\n4\n12\n1950-04-12\n8527\n0\nNA\nNA\nNA\n052d9254-80e8-428f-b8b6-69518b0ef3f3\nM\n0\nwhite\n0\nitalian\n0\n\n\n129\n8507\n1974\n10\n7\n1974-10-07\n8527\n0\nNA\nNA\nNA\n054d32d5-904f-4df4-846b-8c08d165b4e9\nM\n0\nwhite\n0\npolish\n0\n\n\n16\n8532\n1971\n10\n13\n1971-10-13\n8527\n0\nNA\nNA\nNA\n00444703-f2c9-45c9-a247-f6317a43a929\nF\n0\nwhite\n0\namerican\n0\n\n\n65\n8532\n1967\n3\n31\n1967-03-31\n8516\n0\nNA\nNA\nNA\n02a3dad9-f9d5-42fb-8074-c16d45b4f5c8\nF\n0\nblack\n0\ndominican\n0\n\n\n74\n8532\n1972\n1\n5\n1972-01-05\n8527\n0\nNA\nNA\nNA\n02fbf1be-29b7-4da8-8bbd-14c7433f843f\nF\n0\nwhite\n0\nenglish\n0\n\n\n42\n8532\n1909\n11\n2\n1909-11-02\n8527\n0\nNA\nNA\nNA\n0177d2e0-98f5-4f3d-bcfd-497b7a07b3f8\nF\n0\nwhite\n0\nirish\n0\n\n\n187\n8507\n1945\n7\n23\n1945-07-23\n8527\n0\nNA\nNA\nNA\n07a1e14d-73ed-4d3a-9a39-d729745773fa\nM\n0\nwhite\n0\nirish\n0\n\n\n18\n8532\n1965\n11\n17\n1965-11-17\n8527\n0\nNA\nNA\nNA\n0084b0fe-e30f-4930-b6d1-5e1eff4b7dea\nF\n0\nwhite\n0\nenglish\n0\n\n\n111\n8532\n1975\n5\n2\n1975-05-02\n8527\n0\nNA\nNA\nNA\n0478d6b3-bdb3-4574-9b93-cf448d725b84\nF\n0\nwhite\n0\nenglish\n0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Table Reference</span>"
    ]
  },
  {
    "objectID": "tableref.html#procedure_occurrence-table",
    "href": "tableref.html#procedure_occurrence-table",
    "title": "\n7  Table Reference\n",
    "section": "\n7.2 procedure_occurrence table:",
    "text": "7.2 procedure_occurrence table:\n\nSELECT * FROM procedure_occurrence LIMIT 10;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprocedure_occurrence_id\nperson_id\nprocedure_concept_id\nprocedure_date\nprocedure_datetime\nprocedure_type_concept_id\nmodifier_concept_id\nquantity\nprovider_id\nvisit_occurrence_id\nvisit_detail_id\nprocedure_source_value\nprocedure_source_concept_id\nmodifier_source_value\n\n\n\n3554\n343\n4107731\n1992-02-01\n1992-02-01\n38000275\n0\nNA\nNA\n22951\n0\n180256009\n4107731\nNA\n\n\n3741\n357\n4107731\n1990-11-14\n1990-11-14\n38000275\n0\nNA\nNA\n23670\n0\n180256009\n4107731\nNA\n\n\n3928\n399\n4107731\n1991-09-08\n1991-09-08\n38000275\n0\nNA\nNA\n26205\n0\n180256009\n4107731\nNA\n\n\n4115\n406\n4107731\n1990-02-13\n1990-02-13\n38000275\n0\nNA\nNA\n26759\n0\n180256009\n4107731\nNA\n\n\n4302\n411\n4107731\n1992-01-11\n1992-01-11\n38000275\n0\nNA\nNA\n27401\n0\n180256009\n4107731\nNA\n\n\n4489\n430\n4058899\n1938-10-11\n1938-10-11\n38000275\n0\nNA\nNA\n28537\n0\n168594001\n4058899\nNA\n\n\n4676\n442\n4107731\n1992-10-31\n1992-10-31\n38000275\n0\nNA\nNA\n29330\n0\n180256009\n4107731\nNA\n\n\n4863\n453\n4043071\n1984-03-20\n1984-03-20\n38000275\n0\nNA\nNA\n30237\n0\n228557008\n4043071\nNA\n\n\n5050\n469\n4043071\n1948-04-26\n1948-04-26\n38000275\n0\nNA\nNA\n31282\n0\n228557008\n4043071\nNA\n\n\n5237\n488\n4151422\n1962-09-21\n1962-09-21\n38000275\n0\nNA\nNA\n32616\n0\n269911007\n4151422\nNA",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Table Reference</span>"
    ]
  },
  {
    "objectID": "tableref.html#concept-table",
    "href": "tableref.html#concept-table",
    "title": "\n7  Table Reference\n",
    "section": "\n7.3 concept table",
    "text": "7.3 concept table\n\nSELECT * FROM concept LIMIT 10;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\nconcept_id\nconcept_name\ndomain_id\nvocabulary_id\nconcept_class_id\nstandard_concept\nconcept_code\nvalid_start_date\nvalid_end_date\ninvalid_reason\n\n\n\n35208414\nGastrointestinal hemorrhage, unspecified\nCondition\nICD10CM\n4-char billing code\nNA\nK92.2\n2007-01-01\n2099-12-31\nNA\n\n\n1118088\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\nRxNorm\nBranded Drug\nS\n213469\n1970-01-01\n2099-12-31\nNA\n\n\n40213201\npneumococcal polysaccharide vaccine, 23 valent\nDrug\nCVX\nCVX\nS\n33\n2008-12-01\n2099-12-31\nNA\n\n\n1557272\nAlendronate\nDrug\nRxNorm\nIngredient\nS\n46041\n1970-01-01\n2099-12-31\nNA\n\n\n4336464\nCoronary artery bypass graft\nProcedure\nSNOMED\nProcedure\nS\n232717009\n1970-01-01\n2099-12-31\nNA\n\n\n4295880\nIntramuscular injection\nProcedure\nSNOMED\nProcedure\nS\n76601001\n1970-01-01\n2099-12-31\nNA\n\n\n3020630\nProtein serum/plasma\nMeasurement\nLOINC\nLab Test\nS\n2885-2\n1970-01-01\n2099-12-31\nNA\n\n\n19129655\nAmpicillin 100 MG/ML Injectable Solution\nDrug\nRxNorm\nClinical Drug\nS\n789980\n2008-03-30\n2099-12-31\nNA\n\n\n44923712\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\nNDC\n11-digit NDC\nNA\n00025152531\n2000-01-01\n2099-12-31\nNA\n\n\n1569708\nOther diseases of digestive system\nCondition\nICD10CM\n3-char nonbill code\nNA\nK92\n2012-01-01\n2099-12-31\nNA",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Table Reference</span>"
    ]
  },
  {
    "objectID": "tableref.html#condition_occurrence-table",
    "href": "tableref.html#condition_occurrence-table",
    "title": "\n7  Table Reference\n",
    "section": "\n7.4 condition_occurrence table",
    "text": "7.4 condition_occurrence table\n\nSELECT * FROM condition_occurrence LIMIT 10;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncondition_occurrence_id\nperson_id\ncondition_concept_id\ncondition_start_date\ncondition_start_datetime\ncondition_end_date\ncondition_end_datetime\ncondition_type_concept_id\ncondition_status_concept_id\nstop_reason\nprovider_id\nvisit_occurrence_id\nvisit_detail_id\ncondition_source_value\ncondition_source_concept_id\ncondition_status_source_value\n\n\n\n4483\n263\n4112343\n2015-10-02\n2015-10-02\n2015-10-14\n2015-10-14\n32020\n0\nNA\nNA\n17479\n0\n195662009\n4112343\nNA\n\n\n4657\n273\n192671\n2011-10-10\n2011-10-10\nNA\nNA\n32020\n0\nNA\nNA\n18192\n0\nK92.2\n35208414\nNA\n\n\n4815\n283\n28060\n1984-02-15\n1984-02-15\n1984-02-25\n1984-02-25\n32020\n0\nNA\nNA\n18859\n0\n43878008\n28060\nNA\n\n\n4981\n293\n378001\n2005-11-07\n2005-11-07\n2005-12-07\n2005-12-07\n32020\n0\nNA\nNA\n19515\n0\n62106007\n378001\nNA\n\n\n5153\n304\n257012\n1974-07-30\n1974-07-30\n1974-11-05\n1974-11-05\n32020\n0\nNA\nNA\n20239\n0\n40055000\n257012\nNA\n\n\n5313\n312\n4134304\n1991-05-14\n1991-05-14\n1991-06-13\n1991-06-13\n32020\n0\nNA\nNA\n20658\n0\n263102004\n4134304\nNA\n\n\n5513\n326\n28060\n1979-09-23\n1979-09-23\n1979-10-06\n1979-10-06\n32020\n0\nNA\nNA\n21553\n0\n43878008\n28060\nNA\n\n\n5655\n334\n40481087\n1999-07-12\n1999-07-12\n1999-07-19\n1999-07-19\n32020\n0\nNA\nNA\n22124\n0\n444814009\n40481087\nNA\n\n\n5811\n341\n40481087\n1990-09-14\n1990-09-14\n1990-10-05\n1990-10-05\n32020\n0\nNA\nNA\n22784\n0\n444814009\n40481087\nNA\n\n\n5977\n351\n40481087\n1986-02-24\n1986-02-24\n1986-03-17\n1986-03-17\n32020\n0\nNA\nNA\n23405\n0\n444814009\n40481087\nNA",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Table Reference</span>"
    ]
  }
]