[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Intro to SQL",
    "section": "",
    "text": "Intro to SQL",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#course-description",
    "href": "index.html#course-description",
    "title": "Intro to SQL",
    "section": "Course Description",
    "text": "Course Description\nData that we need to utilize and query is often stored in data sources such as databases or data warehouses. In this course, you will learn how to connect and query databases using Structured Query Language (SQL). In particular, we will focus on querying data in a commonly used data model for storing patient data called OMOP. By the end of this course, you will be prepared to construct complex queries to retrieve large data sets and automate these queries to produce automated reports and dashboards.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "Intro to SQL",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nExplain data sources such as Databases and how to connect to them\nQuery data sources using database engines and Structured Query Language (SQL) to filter, join, and aggregate data\nConstruct and calculate new fields using SELECT or CASE WHEN\n(optional) Read and explain a sample OMOP query: https://github.com/OHDSI/OMOP-Queries/tree/master",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#instructors",
    "href": "index.html#instructors",
    "title": "Intro to SQL",
    "section": "Instructors",
    "text": "Instructors\nIf you need to schedule some time to talk, please schedule with Ted.\n\nTed Laderas, Director of Training and Community, Office of the Chief Data Officer\nVivek Sriram, Data Scientist, Office of the Chief Data Officer",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#introductions",
    "href": "index.html#introductions",
    "title": "Intro to SQL",
    "section": "Introductions",
    "text": "Introductions\nIn chat, please introduce yourself:\n\nYour Name & Your Group\nWhat you want to learn in this course\nFavorite Winter activity",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#tentative-schedule",
    "href": "index.html#tentative-schedule",
    "title": "Intro to SQL",
    "section": "Tentative Schedule",
    "text": "Tentative Schedule\nAll classes are on Fridays from 12:00-1:30 PM PST. Connection details will be provided. Office hours related to each class day are posted below, and the invite will be sent to you.\nIn class we will be going through the Quarto Notebooks that are hosted on Posit.cloud. No knowledge of R is necessary, we’ll show you what you need to know in class.\nClasses will be recorded, and those recordings will be sent to you after each class.\n\n\n\nWeek\nDate\nSubject\nOffice Hours\n\n\n\n\nPre-class\n—-\nConcepts of Databases\n\n\n\n1\nFeb 7\nIntro to SQL; SHOW TABLES, DESCRIBE, SELECT, WHERE\nFeb 11\n\n\n2\nFeb 14\nJOINing tables, more WHERE\nFeb 25\n\n\n-\nFeb 21\nNo class (school break week)\nNo office hours\n\n\n3\nFeb 28\nCalculating new fields, GROUP BY, CASE WHEN, HAVING\nMar 4\n\n\n4\nMar 7\nSubqueries/Views, Recap of course / review OMOP queries\nNo office hours",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#format-of-class",
    "href": "index.html#format-of-class",
    "title": "Intro to SQL",
    "section": "Format of Class",
    "text": "Format of Class\nI will teach online only, though you have the option of attending in the DaSL Lounge (Arnold M1-B406), which will have snacks and drinks available. Either Chris Lo or Vivek Sriram will host in person.\nWe will spend the first 20-25 minutes of each class on catching up on last week’s exercises if you haven’t had the opportunity to work on them. Followed by that, we will have a short lecture/lab, where we will go through the notebooks for the week.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#first-class-survey",
    "href": "index.html#first-class-survey",
    "title": "Intro to SQL",
    "section": "First Class Survey",
    "text": "First Class Survey\nFirst Class Survey - Please fill out. We mostly want to see how confident you are before and after class. We will share these results with everyone (anonymized).",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#weekly-check-in",
    "href": "index.html#weekly-check-in",
    "title": "Intro to SQL",
    "section": "Weekly Check In",
    "text": "Weekly Check In\nWeekly Check In Form - please fill out to let us know if you have any issues or want to share what you’ve learned. We look at the answers in aggregate and we anonymize responses (unless you want us to know).",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#posit-cloud-intro",
    "href": "index.html#posit-cloud-intro",
    "title": "Intro to SQL",
    "section": "Posit Cloud Intro",
    "text": "Posit Cloud Intro\nHere is a short video introducing you to the Posit Cloud interface.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#culture-of-the-course",
    "href": "index.html#culture-of-the-course",
    "title": "Intro to SQL",
    "section": "Culture of the course",
    "text": "Culture of the course\n\nLearning on the job is challenging\n\nI will move at learner’s pace; we are learning together.\nTeach not for mastery, but teach for empowerment to learn effectively.\n\n\nWe sometimes struggle with our data science in isolation, unaware that someone two doors down from us has gone through the same struggle.\n\nWe learn and work better with our peers.\nKnow that if you have a question, other people will have it.\nAsking questions is our way of taking care of others.\n\nWe ask you to follow Participation Guidelines and Code of Conduct.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#available-course-formats",
    "href": "index.html#available-course-formats",
    "title": "Intro to SQL",
    "section": "Available Course Formats",
    "text": "Available Course Formats\nThis course is available in multiple formats which allows you to take it in the way that best suites your needs.\n\nThe material for this course can be viewed without login requirement on this website. This format might be most appropriate for you if you rely on screen-reader technology.\nThe material is also available to Fred Hutch Consortia students via Posit Cloud.\nOur courses are open source, you can find the source material for this course on GitHub.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "concepts.html",
    "href": "concepts.html",
    "title": "\n1  Database Concepts\n",
    "section": "",
    "text": "1.1 What is a Database?\nWhen we talk about databases, we mean the database system rather than database itself. Specifically, we talk about the different layers of a database system.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#what-is-a-database",
    "href": "concepts.html#what-is-a-database",
    "title": "\n1  Database Concepts\n",
    "section": "",
    "text": "A database is an organized collection of structured information, or data, typically stored electronically in a computer system. A database is usually controlled by a database management system (DBMS). Together, the data and the DBMS, along with the applications that are associated with them, are referred to as a database system, often shortened to just database. - Oracle Documentation",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#parts-of-a-database-system",
    "href": "concepts.html#parts-of-a-database-system",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.2 Parts of a Database System",
    "text": "1.2 Parts of a Database System\nThe Composable Codex talks about three layers of a database system:\nFrom the Composable Codex\n\n\nA user interface - how users interact with the database. In this class, our main way of interacting with databases is SQL (Structured Query Language).\n\nAn execution engine - a software system that queries the data in storage. There are many examples of this: SQL Server, MariaDB, DuckDB, Snowflake. These can live on our machine, on a server within our network, or a server on the cloud.\n\nData Storage - the physical location where the data is stored. This could be on your computer, on the network, or in the cloud (such as an Amazon S3 bucket)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#for-this-class",
    "href": "concepts.html#for-this-class",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.3 For this class",
    "text": "1.3 For this class\nIn our class, we will use the following configuration:\n\n\n\n\n\ngraph TD\nA[\"1.SQL\"] --&gt; B\nB[\"2.DuckDB\"] --&gt; C\nC[\"3.File on our Machine\"]\n\n\n\n\n\n\n\n\n\n\n\n\nWhy We’re Using DuckDB in this Course\n\n\n\nDuckDB is a very fast, open-source database engine. Because of restrictions on clinical data, sometimes the only way to analyze it is on an approved laptop. DuckDB does wondrous things on laptops, so we hope it will be a helpful tool in your arsenal.\nIt is what is called an analytical database engine, which means it is very fast for reading and querying data. This is compared to a transactional database engine, which must handle multiple users interacting and inserting data into the database at once.\n\n\nBut you can think of other configurations that might be more applicable to you. For example, a lot of groups at the Hutch use SQL Server:\n\n\n\n\n\ngraph TD\nA[\"1.SQL\"] --&gt; B\nB[\"2.SQL Server\"] --&gt; C\nC[\"3.FH Shared Storage\"]\n\n\n\n\n\n\nIn many ways, SQL Server and its storage are tightly coupled (the engine and the storage are in the same location). This coupling can make it difficult to migrate out of such systems.\nOr, for those who want to use cloud-based systems, we can have this configuration:\n\n\n\n\n\ngraph TD\nA[\"1.SQL/Notebooks\"] --&gt; B\nB[\"2.Databricks/Snowflake\"] --&gt; C\nC[\"3.Amazon S3\"]\n\n\n\n\n\n\nIn this case, we need to sign into the Databricks system, which is a set of systems that lives in the cloud. We actually will use SQL within their notebooks to write our queries. Databricks will then use the Snowflake engine to query the data that is stored in cloud storage (an S3 bucket).\nIf this is making you dizzy, don’t worry too much about it. Just know that we can switch out the different layers based on our needs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#what-is-sql",
    "href": "concepts.html#what-is-sql",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.4 What is SQL?",
    "text": "1.4 What is SQL?\nSQL is short for Structured Query Language. It is a standardized language for querying databases (originally relational databases)\nSQL lets us do various operations on data. It contains various clauses which let us manipulate data:\n\n\n\n\n\n\n\nPriority\nClause\nPurpose\n\n\n\n1\nFROM\nChoose tables to query and specify how to JOIN them together\n\n\n2\nWHERE\nFilter tables based on criteria\n\n\n3\nGROUP BY\nAggregates the Data\n\n\n4\nHAVING\nFilters Aggregated Data\n\n\n5\nSELECT\nSelects columns in table and calculate new columns\n\n\n6\nORDER BY\nSorts by a database field\n\n\n7\nLIMIT\nLimits the number of records returned\n\n\n\nWe do not use all of these clauses when we write a SQL Query. We only use the ones we need to get the data we need out.\nOftentimes, we really only want a summary out of the database. We would probably use the following clauses:\n\n\n\n\n\n\n\nPriority\nClause\nPurpose\n\n\n\n1\nFROM\nChoose tables to query and specify how to JOIN them together\n\n\n2\nWHERE\nFilter tables based on criteria\n\n\n3\nGROUP BY\nAggregates the Data\n\n\n5\nSELECT\nSelects columns in table and calculate new columns\n\n\n\nNotice that there is a Priority column in these tables. This is important, because parts of queries are evaluated in this order.\n\n\n\n\n\n\nDialects of SQL\n\n\n\nYou may have heard that the SQL used in SQL Server is different than other databases. In truth, there are multiple dialects of SQL, based on the engine.\nHowever, we’re focusing on the 95% of SQL that is common to all systems. Most of the time, the SQL we’re showing you in this course will get you to where you want to go.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#anatomy-of-a-sql-statement",
    "href": "concepts.html#anatomy-of-a-sql-statement",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.5 Anatomy of a SQL Statement",
    "text": "1.5 Anatomy of a SQL Statement\nLet’s look at a typical SQL statement:\nSELECT person_id, gender_source_value   # Choose Columns\n  FROM person                           # Choose the person table\n  WHERE year_of_birth &lt; 2000;            # Filter the data using a criterion\nWe can read this as:\nSELECT the person_id and gender_source_value columns\nFROM the person table\nONLY Those with year of birth less than 2000 \nAs you can see, SQL can be read. We will gradually introduce clauses and different database operations.\n\n\n\n\n\n\nNote\n\n\n\nAs a convention, we will capitalize SQL clauses (such as SELECT), and use lowercase for everything else.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#database-connections",
    "href": "concepts.html#database-connections",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.6 Database Connections",
    "text": "1.6 Database Connections\nWe haven’t really talked about how we connect to the database engine.\nIn order to connect to the database engine and create a database connection, we may have to authenticate with an ID/password combo or use other methods of authentication to prove who we are.\nOnce we are authenticated, we now have a connection. This is basically our conduit to the database engine. We can send queries through it, and the database engine will run these queries, and return a result.\n\n\n\n\n\ngraph LR\n  A[\"Our Computer\"] --query--&gt; B[Database Engine]\n  B --results--&gt; A\n\n\n\n\n\n\nAs long as the connection is open, we can continue to send queries and receive results.\nIt is best practice to explicitly disconnect from the database. Once we have disconnected, we no longer have access to the database.\n\n\n\n\n\ngraph LR\n  A[\"Our Computer\"] --X--&gt; B[Database Engine]\n  B --X--&gt; A",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#how-is-the-data-stored",
    "href": "concepts.html#how-is-the-data-stored",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.7 How is the Data Stored?",
    "text": "1.7 How is the Data Stored?\nTypically, the data in databases is stored in tables, such as the one below:\n\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nperson_id\ngender_concept_id\nyear_of_birth\nmonth_of_birth\nday_of_birth\nbirth_datetime\nrace_concept_id\nethnicity_concept_id\nlocation_id\nprovider_id\ncare_site_id\nperson_source_value\ngender_source_value\ngender_source_concept_id\nrace_source_value\nrace_source_concept_id\nethnicity_source_value\nethnicity_source_concept_id\n\n\n\n6\n8532\n1963\n12\n31\n1963-12-31\n8516\n0\nNA\nNA\nNA\n001f4a87-70d0-435c-a4b9-1425f6928d33\nF\n0\nblack\n0\nwest_indian\n0\n\n\n123\n8507\n1950\n4\n12\n1950-04-12\n8527\n0\nNA\nNA\nNA\n052d9254-80e8-428f-b8b6-69518b0ef3f3\nM\n0\nwhite\n0\nitalian\n0\n\n\n129\n8507\n1974\n10\n7\n1974-10-07\n8527\n0\nNA\nNA\nNA\n054d32d5-904f-4df4-846b-8c08d165b4e9\nM\n0\nwhite\n0\npolish\n0\n\n\n16\n8532\n1971\n10\n13\n1971-10-13\n8527\n0\nNA\nNA\nNA\n00444703-f2c9-45c9-a247-f6317a43a929\nF\n0\nwhite\n0\namerican\n0\n\n\n65\n8532\n1967\n3\n31\n1967-03-31\n8516\n0\nNA\nNA\nNA\n02a3dad9-f9d5-42fb-8074-c16d45b4f5c8\nF\n0\nblack\n0\ndominican\n0\n\n\n74\n8532\n1972\n1\n5\n1972-01-05\n8527\n0\nNA\nNA\nNA\n02fbf1be-29b7-4da8-8bbd-14c7433f843f\nF\n0\nwhite\n0\nenglish\n0\n\n\n42\n8532\n1909\n11\n2\n1909-11-02\n8527\n0\nNA\nNA\nNA\n0177d2e0-98f5-4f3d-bcfd-497b7a07b3f8\nF\n0\nwhite\n0\nirish\n0\n\n\n187\n8507\n1945\n7\n23\n1945-07-23\n8527\n0\nNA\nNA\nNA\n07a1e14d-73ed-4d3a-9a39-d729745773fa\nM\n0\nwhite\n0\nirish\n0\n\n\n18\n8532\n1965\n11\n17\n1965-11-17\n8527\n0\nNA\nNA\nNA\n0084b0fe-e30f-4930-b6d1-5e1eff4b7dea\nF\n0\nwhite\n0\nenglish\n0\n\n\n111\n8532\n1975\n5\n2\n1975-05-02\n8527\n0\nNA\nNA\nNA\n0478d6b3-bdb3-4574-9b93-cf448d725b84\nF\n0\nwhite\n0\nenglish\n0\n\n\n\n\n\nSome quick terminology:\n\n\nDatabase Record - a row in this table. In this case, each row in the table above corresponds to a single person.\n\nDatabase Field - the columns in this table. In our case, each column corresponds to a single measurement, such as birth_datetime. Each column has a specific datatype, which may be integers, decimals, dates, a short text field, or longer text fields. Think of them like the different pieces of information requested in a form.\n\nIt is faster and requires less memory if we do not use a single large table, but decompose the data up into multiple tables. These tables are stored in a number of different formats:\n\nComma Separated Value (CSV)\nA Single File (SQL Server)\na virtual file\n\n\nIn a virtual file, the data acts like it is stored in a single file, but is actually many different files underneath that can be on your machine, on the network, or on the cloud. The virtual file lets us interact with this large mass of data as if it is a single file.\nThe database engine is responsible for scanning the data, either row by row, or column by column. The engines are made to be very fast in this scanning to return relevant records.\n\n\n\n\n\n\nRows versus Columns\n\n\n\nJust a quick note about row-based storage vs column-based storage. SQL was originally written for relational databases, which are stored by row.\nA new trick is column-based storage. It turns out that it’s actually faster to query the data in many instances when the data in a column is all stored together. These are the formats like Parquet that you might have heard about. A lot of newer database engines rely on the data to be stored in this format.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "week1.html",
    "href": "week1.html",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "",
    "text": "2.1 Our Composable Database System",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#our-composable-database-system",
    "href": "week1.html#our-composable-database-system",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "",
    "text": "Client: R/RStudio w/ SQL\nDatabase Engine: DuckDB\nData Storage: single file in data/ folder",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#connecting-to-our-database",
    "href": "week1.html#connecting-to-our-database",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.2 Connecting to our database",
    "text": "2.2 Connecting to our database\nTo access the data, we need to create a database connection. We use dbConnect() from the DBI package to do this. The first argument specifies the Database engine (duckdb()), and the second provides the file location: \"data/data/GiBleed_5.3_1.1.duckdb\".\n\nlibrary(duckdb)\n\nLoading required package: DBI\n\nlibrary(DBI)\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), \n                      \"data/GiBleed_5.3_1.1.duckdb\")\n\nOnce open, we can use con (our database connection)\n\n\n\n\n\n\nKeep in Mind: SQL ignores letter case\n\n\n\nThese are the same to the database engine:\nSELECT person_id FROM person;\nselect PERSON_ID FROM person;\nAnd so on. Our convention is that we capitalize SQL clauses such as SELECT so you can differentiate them from other information.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#looking-at-the-entire-database",
    "href": "week1.html#looking-at-the-entire-database",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.3 Looking at the Entire Database",
    "text": "2.3 Looking at the Entire Database\nOne of the first things we can learn is to show the contents of the entire database; we can do this with SHOW TABLES:\n\nSHOW TABLES;\n\n\nDisplaying records 1 - 10\n\nname\n\n\n\ncare_site\n\n\ncdm_source\n\n\nconcept\n\n\nconcept_ancestor\n\n\nconcept_class\n\n\nconcept_relationship\n\n\nconcept_synonym\n\n\ncondition_era\n\n\ncondition_occurrence\n\n\ncost\n\n\n\n\n\nWe can get further information about the tables within our database using DESCRIBE; This will give us more information about individual tables:\n\nDESCRIBE;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\ndatabase\nschema\nname\ncolumn_names\ncolumn_types\ntemporary\n\n\n\nGiBleed_5\nmain\ncare_site\ncare_site_id , care_site_name , place_of_service_concept_id , location_id , care_site_source_value , place_of_service_source_value\nINTEGER, VARCHAR, INTEGER, INTEGER, VARCHAR, VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\ncdm_source\ncdm_source_name , cdm_source_abbreviation , cdm_holder , source_description , source_documentation_reference, cdm_etl_reference , source_release_date , cdm_release_date , cdm_version , vocabulary_version\nVARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, DATE , DATE , VARCHAR, VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\nconcept\nconcept_id , concept_name , domain_id , vocabulary_id , concept_class_id, standard_concept, concept_code , valid_start_date, valid_end_date , invalid_reason\nINTEGER, VARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, DATE , DATE , VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\nconcept_ancestor\nancestor_concept_id , descendant_concept_id , min_levels_of_separation, max_levels_of_separation\nINTEGER, INTEGER, INTEGER, INTEGER\nFALSE\n\n\nGiBleed_5\nmain\nconcept_class\nconcept_class_id , concept_class_name , concept_class_concept_id\nVARCHAR, VARCHAR, INTEGER\nFALSE\n\n\nGiBleed_5\nmain\nconcept_relationship\nconcept_id_1 , concept_id_2 , relationship_id , valid_start_date, valid_end_date , invalid_reason\nINTEGER, INTEGER, VARCHAR, DATE , DATE , VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\nconcept_synonym\nconcept_id , concept_synonym_name, language_concept_id\nINTEGER, VARCHAR, INTEGER\nFALSE\n\n\nGiBleed_5\nmain\ncondition_era\ncondition_era_id , person_id , condition_concept_id , condition_era_start_date , condition_era_end_date , condition_occurrence_count\nINTEGER, INTEGER, INTEGER, DATE , DATE , INTEGER\nFALSE\n\n\nGiBleed_5\nmain\ncondition_occurrence\ncondition_occurrence_id , person_id , condition_concept_id , condition_start_date , condition_start_datetime , condition_end_date , condition_end_datetime , condition_type_concept_id , condition_status_concept_id , stop_reason , provider_id , visit_occurrence_id , visit_detail_id , condition_source_value , condition_source_concept_id , condition_status_source_value\nINTEGER , INTEGER , INTEGER , DATE , TIMESTAMP, DATE , TIMESTAMP, INTEGER , INTEGER , VARCHAR , INTEGER , INTEGER , INTEGER , VARCHAR , INTEGER , VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\ncost\ncost_id , cost_event_id , cost_domain_id , cost_type_concept_id , currency_concept_id , total_charge , total_cost , total_paid , paid_by_payer , paid_by_patient , paid_patient_copay , paid_patient_coinsurance , paid_patient_deductible , paid_by_primary , paid_ingredient_cost , paid_dispensing_fee , payer_plan_period_id , amount_allowed , revenue_code_concept_id , revenue_code_source_value, drg_concept_id , drg_source_value\nINTEGER, INTEGER, VARCHAR, INTEGER, INTEGER, FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , INTEGER, FLOAT , INTEGER, VARCHAR, INTEGER, VARCHAR\nFALSE\n\n\n\n\n\nWe’ll look at a few tables in our work:\n\n\nperson - Contains personal & demographic data\n\nprocedure_occurrence - procedures performed on patients and when they happened\n\ncondition_occurrence - patient conditions (such as illnesses) and when they occurred\n\nconcept - contains the specific information (names of concepts) that map into all three above tables\n\nWe’ll talk much more later about the relationships between these tables.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#select-and-from",
    "href": "week1.html#select-and-from",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.4 SELECT and FROM\n",
    "text": "2.4 SELECT and FROM\n\nIf we want to see the contents of a table, we can use SELECT and FROM.\nSELECT *          # select all columns\n  FROM person     # from the person table\n  LIMIT 10;       # return only 10 rows\n\nSELECT * FROM person LIMIT 10;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nperson_id\ngender_concept_id\nyear_of_birth\nmonth_of_birth\nday_of_birth\nbirth_datetime\nrace_concept_id\nethnicity_concept_id\nlocation_id\nprovider_id\ncare_site_id\nperson_source_value\ngender_source_value\ngender_source_concept_id\nrace_source_value\nrace_source_concept_id\nethnicity_source_value\nethnicity_source_concept_id\n\n\n\n6\n8532\n1963\n12\n31\n1963-12-31\n8516\n0\nNA\nNA\nNA\n001f4a87-70d0-435c-a4b9-1425f6928d33\nF\n0\nblack\n0\nwest_indian\n0\n\n\n123\n8507\n1950\n4\n12\n1950-04-12\n8527\n0\nNA\nNA\nNA\n052d9254-80e8-428f-b8b6-69518b0ef3f3\nM\n0\nwhite\n0\nitalian\n0\n\n\n129\n8507\n1974\n10\n7\n1974-10-07\n8527\n0\nNA\nNA\nNA\n054d32d5-904f-4df4-846b-8c08d165b4e9\nM\n0\nwhite\n0\npolish\n0\n\n\n16\n8532\n1971\n10\n13\n1971-10-13\n8527\n0\nNA\nNA\nNA\n00444703-f2c9-45c9-a247-f6317a43a929\nF\n0\nwhite\n0\namerican\n0\n\n\n65\n8532\n1967\n3\n31\n1967-03-31\n8516\n0\nNA\nNA\nNA\n02a3dad9-f9d5-42fb-8074-c16d45b4f5c8\nF\n0\nblack\n0\ndominican\n0\n\n\n74\n8532\n1972\n1\n5\n1972-01-05\n8527\n0\nNA\nNA\nNA\n02fbf1be-29b7-4da8-8bbd-14c7433f843f\nF\n0\nwhite\n0\nenglish\n0\n\n\n42\n8532\n1909\n11\n2\n1909-11-02\n8527\n0\nNA\nNA\nNA\n0177d2e0-98f5-4f3d-bcfd-497b7a07b3f8\nF\n0\nwhite\n0\nirish\n0\n\n\n187\n8507\n1945\n7\n23\n1945-07-23\n8527\n0\nNA\nNA\nNA\n07a1e14d-73ed-4d3a-9a39-d729745773fa\nM\n0\nwhite\n0\nirish\n0\n\n\n18\n8532\n1965\n11\n17\n1965-11-17\n8527\n0\nNA\nNA\nNA\n0084b0fe-e30f-4930-b6d1-5e1eff4b7dea\nF\n0\nwhite\n0\nenglish\n0\n\n\n111\n8532\n1975\n5\n2\n1975-05-02\n8527\n0\nNA\nNA\nNA\n0478d6b3-bdb3-4574-9b93-cf448d725b84\nF\n0\nwhite\n0\nenglish\n0\n\n\n\n\n\n\nWhy are there birth_datetime and the month_of_birth, day_of_birth, year_of_birth - aren’t these redundant?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#try-it-out",
    "href": "week1.html#try-it-out",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.5 Try it Out",
    "text": "2.5 Try it Out\nLook at the first few rows of procedure_occurrence.\n\nSELECT * FROM ____ LIMIT 10;\n\n\nWhy is there a person_id column in this table as well?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#selecting-a-few-columns-in-our-table",
    "href": "week1.html#selecting-a-few-columns-in-our-table",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.6 SELECTing a few columns in our table",
    "text": "2.6 SELECTing a few columns in our table\nWe can use the SELECT clause to grab specific columns in our data.\nSELECT person_id, birth_datetime, gender_concept_id # Columns in our table\n  FROM person;                                      # Our Table\n\nSELECT person_id, birth_datetime, gender_concept_id \n  FROM person\n  LIMIT 10;\n\n\nDisplaying records 1 - 10\n\nperson_id\nbirth_datetime\ngender_concept_id\n\n\n\n6\n1963-12-31\n8532\n\n\n123\n1950-04-12\n8507\n\n\n129\n1974-10-07\n8507\n\n\n16\n1971-10-13\n8532\n\n\n65\n1967-03-31\n8532\n\n\n74\n1972-01-05\n8532\n\n\n42\n1909-11-02\n8532\n\n\n187\n1945-07-23\n8507\n\n\n18\n1965-11-17\n8532\n\n\n111\n1975-05-02\n8532",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#try-it-out-1",
    "href": "week1.html#try-it-out-1",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.7 Try it Out",
    "text": "2.7 Try it Out\nWhat happens if we ask for a column that doesn’t exist in our data?\n\nSELECT person_id, birth_datetime, gender_concept_id, blah\n  FROM person;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#check-on-learning",
    "href": "week1.html#check-on-learning",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.8 Check on Learning",
    "text": "2.8 Check on Learning\nAdd race_concept_id and year_of_birth to your SELECT query:\n\nSELECT person_id, birth_datetime, gender_concept_id, ____, ____\n  FROM person;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#where---filtering-our-table",
    "href": "week1.html#where---filtering-our-table",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.9 WHERE - filtering our table",
    "text": "2.9 WHERE - filtering our table\nAdding WHERE to our SQL statement lets us add filtering to our query:\n\nSELECT person_id, gender_source_value, race_source_value, year_of_birth \n  FROM person \n  WHERE year_of_birth &lt; 1980\n\n\nDisplaying records 1 - 10\n\nperson_id\ngender_source_value\nrace_source_value\nyear_of_birth\n\n\n\n6\nF\nblack\n1963\n\n\n123\nM\nwhite\n1950\n\n\n129\nM\nwhite\n1974\n\n\n16\nF\nwhite\n1971\n\n\n65\nF\nblack\n1967\n\n\n74\nF\nwhite\n1972\n\n\n42\nF\nwhite\n1909\n\n\n187\nM\nwhite\n1945\n\n\n18\nF\nwhite\n1965\n\n\n111\nF\nwhite\n1975\n\n\n\n\n\nOne critical thing to know is that you don’t need to include the columns you’re filtering on in the SELECT part of the statement. For example, we could do the following as well, removing year_of_birth from our SELECT:\n\nSELECT person_id, gender_source_value, race_source_value \n  FROM person \n  WHERE year_of_birth &lt; 2000\n\n\nDisplaying records 1 - 10\n\nperson_id\ngender_source_value\nrace_source_value\n\n\n\n6\nF\nblack\n\n\n123\nM\nwhite\n\n\n129\nM\nwhite\n\n\n16\nF\nwhite\n\n\n65\nF\nblack\n\n\n74\nF\nwhite\n\n\n42\nF\nwhite\n\n\n187\nM\nwhite\n\n\n18\nF\nwhite\n\n\n111\nF\nwhite\n\n\n\n\n\n\n2.9.1 Single quotes and WHERE\n\nSQL convention: single quotes (‘M’) refer to values, and double quotes refer to columns (“person_id”). If you try to use double quotes in the below, it will look for a column called “M”.\nThis will trip you up several times if you’re not used to it.\n\nSELECT person_id, gender_source_value, race_source_value \n  FROM person \n  WHERE gender_source_value = 'M'\n  LIMIT 10;\n\n\nDisplaying records 1 - 10\n\nperson_id\ngender_source_value\nrace_source_value\n\n\n\n123\nM\nwhite\n\n\n129\nM\nwhite\n\n\n187\nM\nwhite\n\n\n40\nM\nwhite\n\n\n53\nM\nwhite\n\n\n78\nM\nwhite\n\n\n69\nM\nasian\n\n\n248\nM\nwhite\n\n\n105\nM\nwhite\n\n\n49\nM\nwhite\n\n\n\n\n\nReminder: use single (’’) quotes in your SQL statements to refer to values, not double quotes (“).\n\n\n\n\n\n\nQuick Note\n\n\n\nFor R users, notice the similarity of select() with SELECT. We can rewrite the above in dplyr code as:\nperson |&gt;\n  select(person_id, gender_source_value, race_source_value)\nA lot of dplyr was inspired by SQL. In fact, there is a package called dbplyr that translates dplyr statements into SQL. A lot of us use it, and it’s pretty handy.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#count---how-many-rows",
    "href": "week1.html#count---how-many-rows",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.10 COUNT - how many rows?",
    "text": "2.10 COUNT - how many rows?\nSometimes you want to know the size of your result, not necessarily return the entire set of results. That is what COUNT is for.\n\nSELECT COUNT(*) \n  FROM person\n  WHERE year_of_birth &lt; 2000;\n\n\n1 records\n\ncount_star()\n\n\n2694\n\n\n\n\nSimilarly, when we want to count the number of person_ids returned, we can use COUNT(person_id):\n\nSELECT COUNT(person_id) \n  FROM person\n  WHERE year_of_birth &lt; 2000;\n\n\n1 records\n\ncount(person_id)\n\n\n2694\n\n\n\n\nLet’s switch gears to the procedure_concept_id table. Let’s count the overall number of procedure_concept_ids in our table:\n\nSELECT COUNT(procedure_concept_id)\n  FROM procedure_occurrence;\n\n\n1 records\n\ncount(procedure_concept_id)\n\n\n37409\n\n\n\n\nHmmm. That’s quite a lot, but are there repeat procedure_concept_ids?\nWhen you have repeated values in the rows, COUNT(DISTINCT ) can help you find the number of unique values in a column:\n\nSELECT COUNT(DISTINCT procedure_concept_id)\n  FROM procedure_occurrence\n\n\n1 records\n\ncount(DISTINCT procedure_concept_id)\n\n\n51\n\n\n\n\nWe can also return the actual DISTINCT values by removing COUNT:\n\nSELECT DISTINCT procedure_concept_id\n  FROM procedure_occurrence;\n\n\nDisplaying records 1 - 10\n\nprocedure_concept_id\n\n\n\n4058899\n\n\n4295880\n\n\n4216130\n\n\n4024289\n\n\n4202451\n\n\n4330583\n\n\n4238715\n\n\n4186930\n\n\n4242997\n\n\n4078793",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#check-on-learning-1",
    "href": "week1.html#check-on-learning-1",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.11 Check on Learning",
    "text": "2.11 Check on Learning\nCount the distinct values of gender_source_value in person:\n\nSELECT COUNT(DISTINCT --------------)\n  FROM -------;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#keys-linking-tables-together",
    "href": "week1.html#keys-linking-tables-together",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.12 Keys: Linking tables together",
    "text": "2.12 Keys: Linking tables together\nOne of the important properties of data in a relational database is that there are no repeat rows in the database. Each table that meets this restriction has what is called a primary key.\nWe can use DESCRIBE to get more information (the metadata) about a table. This gives us information about our tables.\n\nDESCRIBE person\n\n\nDisplaying records 1 - 10\n\ncolumn_name\ncolumn_type\nnull\nkey\ndefault\nextra\n\n\n\nperson_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\ngender_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nyear_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nmonth_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nday_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nbirth_datetime\nTIMESTAMP\nYES\nNA\nNA\nNA\n\n\nrace_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nethnicity_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nlocation_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprovider_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\n\n\n\nScanning the rows, which field/column is the primary key for person?\nTry and find the primary key for procedure_occurrence. What is it?\n\nDESCRIBE procedure_occurrence\n\n\nDisplaying records 1 - 10\n\ncolumn_name\ncolumn_type\nnull\nkey\ndefault\nextra\n\n\n\nprocedure_occurrence_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nperson_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprocedure_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprocedure_date\nDATE\nYES\nNA\nNA\nNA\n\n\nprocedure_datetime\nTIMESTAMP\nYES\nNA\nNA\nNA\n\n\nprocedure_type_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nmodifier_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nquantity\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprovider_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nvisit_occurrence_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\n\n\n\nWe’ll see that keys need to be unique (so they can map to each row). In fact, each key is a way to connect one table to another.\nWhat column is the same in both tables? That is a hint for what we’ll cover next week: JOINing tables.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#data-types",
    "href": "week1.html#data-types",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.13 Data Types",
    "text": "2.13 Data Types\nIf you look at the column_type for one of the DESCRIBE statements above, you’ll notice there are different data types:\n\nINTEGER\nTIMESTAMP\nDATE\nVARCHAR\n\nEach column of a database needs to be typed. The data type of a column determines what kinds of calculations or operations we can do on them. For example, we can do things like date arithmetic on DATETIME columns, asking the engine to calculate 5 days after the dates.\nYou can see all of the datatypes that are available in DuckDB here.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#always-close-the-connection",
    "href": "week1.html#always-close-the-connection",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.14 Always close the connection",
    "text": "2.14 Always close the connection\nWhen we’re done, it’s best to close the connection with dbDisconnect().\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week2.html",
    "href": "week2.html",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "",
    "text": "3.1 Connecting to our database\nLet’s connect to our database.\nlibrary(duckdb)\n\nLoading required package: DBI\n\nlibrary(DBI)\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), \n                      \"data/GiBleed_5.3_1.1.duckdb\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#table-references",
    "href": "week2.html#table-references",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.2 Table References",
    "text": "3.2 Table References\nIn single table queries, it is usually unambiguous to the query engine which column and which table you need to query.\nHowever, when you involve multiple tables, it is important to know how to refer to a column in a specific table.\nFor example, the procedure_occurrence table has a person_id column as well. If we want to use this specific column in this table, we can use the . (dot) notation:\nprocedure_occurrence.person_id\nIf we wanted the person_id column in person we can use this:\nperson.person_id\nThis will become much more important as we get into JOINing tables.\n\n3.2.1 Check on Learning\nAdd table references to the WHERE part of the query:\n\nSELECT *\n  FROM procedure_occurrence\n  WHERE person_id = 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#aliases",
    "href": "week2.html#aliases",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.3 Aliases",
    "text": "3.3 Aliases\nAs your queries get more complex, and as you involve more and more tables, you will need to use aliases. I think of them like “nicknames” - they can save you a lot of typing.\nI tend to use the AS clause when I define them. I’ve used AS here to abbreviate person. I use it in two different places: in my COUNT, and in my WHERE:\n\nSELECT COUNT(p.person_id)\n  FROM person AS p\n  WHERE p.year_of_birth &lt; 2000;\n\n\n1 records\n\ncount(p.person_id)\n\n\n2694\n\n\n\n\nSome people don’t use AS, just putting the aliases next to the original name:\n\nSELECT COUNT(p.person_id)\n  FROM person p\n  WHERE p.year_of_birth &lt; 2000;\n\n\n1 records\n\ncount(p.person_id)\n\n\n2694\n\n\n\n\nWe can also rename variables using AS:\n\nSELECT COUNT(person_id) AS person_count\n  FROM person \n  WHERE year_of_birth &lt; 2000;\n\n\n1 records\n\nperson_count\n\n\n2694\n\n\n\n\nNow that we are going to use JOINs, we will be using aliases and table references a lot.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#join",
    "href": "week2.html#join",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.4 JOIN\n",
    "text": "3.4 JOIN\n\nWe use the JOIN clause when we want to combine information from two tables. Here we are going to combine information from two tables: procedure_occurrence and concept.\nTo set the stage, let’s show two tables, x and y. We want to join them by the keys, which are represented by colored boxes in both of the tables.\nNote that table x has a key (“3”) that isn’t in table y, and that table y has a key (“4”) that isn’t in table x.\n\nWe are going to explore INNER JOIN first. In an INNER JOIN, we match up our primary key for our table on the foreign key for another table. In this case, we only retain rows that have keys that exist in both the x and y tables. We drop all rows that don’t have matches in both tables.\n There are other types of joins when we want to retain information from the x table or the y table, or both.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#inner-join-syntax",
    "href": "week2.html#inner-join-syntax",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.5 INNER JOIN syntax",
    "text": "3.5 INNER JOIN syntax\nHere’s an example where we are joining procedure_occurrence with concept:\n\nSELECT procedure_occurrence.person_id, concept.concept_name \n    FROM procedure_occurrence \n    INNER JOIN concept\n    ON procedure_occurrence.procedure_concept_id = concept.concept_id\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\n\n\n\n343\nSubcutaneous immunotherapy\n\n\n357\nSubcutaneous immunotherapy\n\n\n399\nSubcutaneous immunotherapy\n\n\n406\nSubcutaneous immunotherapy\n\n\n411\nSubcutaneous immunotherapy\n\n\n430\nPlain X-ray of clavicle\n\n\n442\nSubcutaneous immunotherapy\n\n\n453\nCognitive and behavioral therapy\n\n\n469\nCognitive and behavioral therapy\n\n\n488\nSputum examination\n\n\n\n\n\nWhat’s going on here? The magic happens with this clause, which we use to specify the two tables we need to join.\nFROM procedure_occurrence\n  INNER JOIN concept\nThe last thing to note is the ON statement. These are the conditions by which we merge rows. Note we are taking one column in procedure.occurrence, the procedure_concept_id, and matching the rows up with those rows in concept\nON procedure_occurrence.procedure_concept_id = concept.concept_id\n\nSELECT procedure_occurrence.person_id, concept.concept_name \n    FROM procedure_occurrence \n    INNER JOIN concept\n    ON procedure_occurrence.procedure_concept_id = concept.concept_id\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\n\n\n\n343\nSubcutaneous immunotherapy\n\n\n357\nSubcutaneous immunotherapy\n\n\n399\nSubcutaneous immunotherapy\n\n\n406\nSubcutaneous immunotherapy\n\n\n411\nSubcutaneous immunotherapy\n\n\n430\nPlain X-ray of clavicle\n\n\n442\nSubcutaneous immunotherapy\n\n\n453\nCognitive and behavioral therapy\n\n\n469\nCognitive and behavioral therapy\n\n\n488\nSputum examination\n\n\n\n\n\nHere is the same query using aliases. We use po as an alias for procedure_occurrence and c as an alias for concept. You can see it is a little more compact.\n\nSELECT po.person_id, c.concept_name \n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id;",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#left-join",
    "href": "week2.html#left-join",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.6 LEFT JOIN\n",
    "text": "3.6 LEFT JOIN\n\n\n\n\n\n\n\nJargon alert\n\n\n\nThe table to the left of the JOIN clause is called the left table, and the table to the right of the JOIN clause is known as the right table. This will become more important as we explore the different join types.\nFROM procedure_occurrence INNER JOIN concept\n      ^^Left Table                    ^^Right Table\n\n\nWhat if we want to retain all of the rows in the procedure_occurrence table, even if there are no matches in the concept table? We can use a LEFT JOIN to do that.\n\nIf a row exists in the left table, but not the right table, it will be replicated in the joined table, but have rows with NULL columns from the right table.\nI tried to find some examples where LEFT JOINed tables were different than INNER JOINed tables, but couldn’t find one good example in our tables. Here is another example:\n Nevertheless, here is an example of a LEFT JOIN:\n\nSELECT  c.concept_name, po.person_id, c.domain_id\n    FROM concept as c \n    LEFT JOIN procedure_occurrence AS po\n    ON po.procedure_concept_id = c.concept_id\n    WHERE c.domain_id = 'Procedure'\n\n\nDisplaying records 1 - 10\n\nconcept_name\nperson_id\ndomain_id\n\n\n\nSubcutaneous immunotherapy\n343\nProcedure\n\n\nSubcutaneous immunotherapy\n357\nProcedure\n\n\nSubcutaneous immunotherapy\n399\nProcedure\n\n\nSubcutaneous immunotherapy\n406\nProcedure\n\n\nSubcutaneous immunotherapy\n411\nProcedure\n\n\nPlain X-ray of clavicle\n430\nProcedure\n\n\nSubcutaneous immunotherapy\n442\nProcedure\n\n\nCognitive and behavioral therapy\n453\nProcedure\n\n\nCognitive and behavioral therapy\n469\nProcedure\n\n\nSputum examination\n488\nProcedure",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#other-kinds-of-joins",
    "href": "week2.html#other-kinds-of-joins",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.7 Other kinds of JOINs",
    "text": "3.7 Other kinds of JOINs\n\nThe RIGHT JOIN is identical to LEFT JOIN, except that the rows preserved are from the right table.\nThe FULL JOIN retains all rows in both tables, regardless if there is a key match.\n\nANTI JOIN is helpful to find all of the keys that are in the left table, but not the right table",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#multiple-joins-with-multiple-tables",
    "href": "week2.html#multiple-joins-with-multiple-tables",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.8 Multiple JOINs with Multiple Tables",
    "text": "3.8 Multiple JOINs with Multiple Tables\nWe can have multiple joins by thinking them as a sequential operation of one join after another. In the below query we first INNER JOIN person and procedure_occurrence, and then use the output of that JOIN to INNER JOIN with concept:\n\nSELECT p.gender_source_value, c.concept_name, po.procedure_date\n  FROM person AS p\n  INNER JOIN procedure_occurrence AS po\n  ON p.person_id = po.person_id\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  LIMIT 10;\n\n\nDisplaying records 1 - 10\n\ngender_source_value\nconcept_name\nprocedure_date\n\n\n\nF\nSubcutaneous immunotherapy\n1992-02-01\n\n\nF\nSubcutaneous immunotherapy\n1990-11-14\n\n\nM\nSubcutaneous immunotherapy\n1991-09-08\n\n\nM\nSubcutaneous immunotherapy\n1990-02-13\n\n\nM\nSubcutaneous immunotherapy\n1992-01-11\n\n\nF\nPlain X-ray of clavicle\n1938-10-11\n\n\nF\nSubcutaneous immunotherapy\n1992-10-31\n\n\nM\nCognitive and behavioral therapy\n1984-03-20\n\n\nF\nCognitive and behavioral therapy\n1948-04-26\n\n\nM\nSputum examination\n1962-09-21\n\n\n\n\n\nThe way I think of these multi-table joins is to decompose them into two joins:\n\nWe first INNER JOIN person and procedure_occurrence, to produce an output table\nWe take this output table and INNER JOIN it with concept.\n\nNotice that both of these JOINs have separate ON statements. For the first join, we have:\nINNER JOIN procedure_occurrence AS po\n  ON p.person_id = po.person_id\nFor the second JOIN, we have:\nINNER JOIN concept AS c\nON po.procedure_concept_id = c.concept_id\nAnd that gives us the final table, which takes variables from all three tables.\nOne thing to keep in mind is that JOINs are not necessarily commutative; that is, the order of joins can matter. This is because we may drop or preserve rows depending on the JOIN.\nFor combining INNER JOINs, we are looking for the subset of keys that exist in each table, so join order doesn’t matter. But for combining LEFT JOINs and RIGHT JOINS, order can matter.\nIt’s really important to check intermediate output and make sure that you are retaining the rows that you need in the final output. For example, I’d try the first join first and see that it contains the rows that I need before adding the second join.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#using-join-with-where",
    "href": "week2.html#using-join-with-where",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.9 Using JOIN with WHERE\n",
    "text": "3.9 Using JOIN with WHERE\n\nWhere we really start to cook with gas is when we combine JOIN with WHERE. Here, we’re joining procedure_occurrence and concept, with an additional WHERE where we only want those rows that have the concept_name of ’Subcutaneous immunotherapy`:\n\nSELECT po.person_id, c.concept_name \n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    WHERE c.concept_name = 'Subcutaneous immunotherapy';\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\n\n\n\n343\nSubcutaneous immunotherapy\n\n\n357\nSubcutaneous immunotherapy\n\n\n399\nSubcutaneous immunotherapy\n\n\n406\nSubcutaneous immunotherapy\n\n\n411\nSubcutaneous immunotherapy\n\n\n442\nSubcutaneous immunotherapy\n\n\n499\nSubcutaneous immunotherapy\n\n\n533\nSubcutaneous immunotherapy\n\n\n563\nSubcutaneous immunotherapy\n\n\n680\nSubcutaneous immunotherapy\n\n\n\n\n\nHere is a triple join query with an additional filter. You can see why aliases are useful:\n\nSELECT po.person_id, c.concept_name, p.birth_datetime \n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    INNER JOIN person as p\n    ON po.person_id = p.person_id\n    WHERE p.year_of_birth &lt; 1980;\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\nbirth_datetime\n\n\n\n343\nSubcutaneous immunotherapy\n1970-01-31\n\n\n357\nSubcutaneous immunotherapy\n1954-10-13\n\n\n399\nSubcutaneous immunotherapy\n1955-04-03\n\n\n406\nSubcutaneous immunotherapy\n1952-02-19\n\n\n411\nSubcutaneous immunotherapy\n1959-02-21\n\n\n430\nPlain X-ray of clavicle\n1931-06-20\n\n\n442\nSubcutaneous immunotherapy\n1947-08-23\n\n\n453\nCognitive and behavioral therapy\n1970-05-15\n\n\n469\nCognitive and behavioral therapy\n1935-11-30\n\n\n488\nSputum examination\n1954-10-01\n\n\n\n\n\n\n\n\n\n\n\nWHERE vs ON\n\n\n\nYou will see variations of SQL statements that eliminate JOIN and ON entirely, putting everything in WHERE:\n\nSELECT po.person_id, c.concept_name \n    FROM procedure_occurrence as po, concept as c\n    WHERE c.concept_name = 'Subcutaneous immunotherapy'\n    AND po.procedure_concept_id = c.concept_id\n    LIMIT 10;\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\n\n\n\n343\nSubcutaneous immunotherapy\n\n\n357\nSubcutaneous immunotherapy\n\n\n399\nSubcutaneous immunotherapy\n\n\n406\nSubcutaneous immunotherapy\n\n\n411\nSubcutaneous immunotherapy\n\n\n442\nSubcutaneous immunotherapy\n\n\n499\nSubcutaneous immunotherapy\n\n\n533\nSubcutaneous immunotherapy\n\n\n563\nSubcutaneous immunotherapy\n\n\n680\nSubcutaneous immunotherapy\n\n\n\n\n\nI’m not the biggest fan of this, because it is often not clear what is a filtering clause and what is a joining clause, so I prefer to use JOIN/ON with a WHERE.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#boolean-logic-and-versus-or",
    "href": "week2.html#boolean-logic-and-versus-or",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.10 Boolean Logic: AND versus OR\n",
    "text": "3.10 Boolean Logic: AND versus OR\n\nRevisiting WHERE, we can combine conditions with AND or OR.\nAND is always going to be more restrictive than OR, because our rows must meet two conditions.\n\nSELECT COUNT(*)\n  FROM person\n  WHERE year_of_birth &lt; 1980 \n  AND gender_source_value = 'M'\n\n\n1 records\n\ncount_star()\n\n\n1261\n\n\n\n\nOn the other hand OR is more permissing than AND, because our rows must meet only one of the conditions.\n\nSELECT COUNT(*)\n  FROM person\n  WHERE year_of_birth &lt; 1980 \n  OR gender_source_value = 'M'\n\n\n1 records\n\ncount_star()\n\n\n2629\n\n\n\n\nThere is also NOT, where one condition must be true, and the other must be false.\n\nSELECT COUNT(*)\n  FROM person\n  WHERE year_of_birth &lt; 1980 \n  AND NOT gender_source_value = 'M'\n\n\n1 records\n\ncount_star()\n\n\n1308",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#order-by",
    "href": "week2.html#order-by",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.11 ORDER BY\n",
    "text": "3.11 ORDER BY\n\nORDER BY lets us sort tables by one or more columns:\n\nSELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.procedure_date;\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\nprocedure_date\n\n\n\n2088\nBone immobilization\n1911-09-07\n\n\n2088\nRadiography of ankle\n1911-09-07\n\n\n2858\nRadiography of wrist\n1912-03-11\n\n\n2858\nBone immobilization\n1912-03-11\n\n\n4165\nSputum examination\n1912-03-15\n\n\n1658\nBrief general examination\n1912-04-30\n\n\n1658\nMedication Reconciliation\n1912-04-30\n\n\n1658\nReview of systems\n1912-04-30\n\n\n4643\nSuture open wound\n1912-12-27\n\n\n4643\nSputum examination\n1913-05-27\n\n\n\n\n\nWe can ORDER BY multiple columns. Column order is important. Try changing the order of the columns in the query below. How is it different?\n\nSELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.person_id, po.procedure_date;\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\nprocedure_date\n\n\n\n1\nBone immobilization\n1958-03-11\n\n\n1\nRadiography of humerus\n1958-03-11\n\n\n1\nRadiologic examination of knee\n1981-08-10\n\n\n1\nSurgical manipulation of joint of knee\n1981-08-17\n\n\n1\nSuture open wound\n1982-09-11\n\n\n2\nBone immobilization\n1924-01-12\n\n\n2\nRadiography of humerus\n1924-01-12\n\n\n2\nSputum examination\n1931-09-03\n\n\n2\nPlain X-ray of clavicle\n1934-01-19\n\n\n2\nSuture open wound\n1952-07-13",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#try-it-out",
    "href": "week2.html#try-it-out",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.12 Try it OUt",
    "text": "3.12 Try it OUt\nTry ordering by po.patient_id:\n\nSELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence AS po \n    INNER JOIN concept AS c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.procedure_date;\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\nprocedure_date\n\n\n\n2088\nBone immobilization\n1911-09-07\n\n\n2088\nRadiography of ankle\n1911-09-07\n\n\n2858\nRadiography of wrist\n1912-03-11\n\n\n2858\nBone immobilization\n1912-03-11\n\n\n4165\nSputum examination\n1912-03-15\n\n\n1658\nBrief general examination\n1912-04-30\n\n\n1658\nMedication Reconciliation\n1912-04-30\n\n\n1658\nReview of systems\n1912-04-30\n\n\n4643\nSuture open wound\n1912-12-27\n\n\n4643\nSputum examination\n1913-05-27",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#transactions-and-inserting-data",
    "href": "week2.html#transactions-and-inserting-data",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.13 Transactions and Inserting Data",
    "text": "3.13 Transactions and Inserting Data\nSo far, we’ve only queried data, but not added data to databases.\nAs we’ve stated before, DuckDB is an Analytical database, not a transactional one. That means it prioritizes reading from data tables rather than inserting into them. Transactional databases, on the other hand, can handle multiple inserts from multiple users at once. They are made for concurrent transactions.\nHere is an example of what is called the Data Definition Language for our tables:\nCREATE TABLE @cdmDatabaseSchema.PERSON (\n            person_id integer NOT NULL,\n            gender_concept_id integer NOT NULL,\n            year_of_birth integer NOT NULL,\n            month_of_birth integer NULL,\n            day_of_birth integer NULL,\n            birth_datetime TIMESTAMP NULL,\n            race_concept_id integer NOT NULL,\n            ethnicity_concept_id integer NOT NULL,\n            location_id integer NULL,\n            provider_id integer NULL,\n            care_site_id integer NULL,\n            person_source_value varchar(50) NULL,\n            gender_source_value varchar(50) NULL,\n            gender_source_concept_id integer NULL,\n            race_source_value varchar(50) NULL,\n            race_source_concept_id integer NULL,\n            ethnicity_source_value varchar(50) NULL,\n            ethnicity_source_concept_id integer NULL );\nWhen we add rows into a database, we need to be aware of the constraints of the database. They exist to maintain the integrity of a database.\nWe’ve encountered one constraint: database fields need to be typed. For example, id keys are usually INTEGER. Names are often VARCHAR.\nOne contraint is the requirement for unique keys for each row. We cannot add a new row with a previous key value.\n\nNOT NULL\nUNIQUE\n\nPRIMARY KEY - NOT NULL + UNIQUE\n\n\nFOREIGN KEY - value must exist as a key in another table\n\nCHECK - check the data type and conditions. One example would be our data shouldn’t be before 1900.\n\nDEFAULT - default values.\n\nThe most important ones to know about are PRIMARY KEY and FOREIGN KEY. PRIMARY KEY forces the database to create new rows with an automatically incremented id.\nWhen we create tables in our database, we need to specify which column is a PRIMARY KEY:\nCREATE TABLE person (\n  person_id INTEGER PRIMARY KEY\n)\nFOREIGN KEY involves two or more tables. If a column is declared a FOREIGN KEY, then that key value must exist in a REFERENCE table. Here our two reference tables are person and procedure_occurrence.\nCREATE TABLE procedure_occurrence {\n  procedure_occurrence_id PRIMARY KEY,\n  person_id INTEGER REFERENCES person(person_id)\n  procedure_concept_id INTEGER REFERENCES concept(concept_id)\n}\nThus, we can use constraints to make sure that our database retains its integrity when we add rows to it.\nThere are more constraints we can add to our tables, and the correct use of these constraints will ensure that our data is correct.\nYou can see an example of constraints for our database here: https://github.com/OHDSI/CommonDataModel/blob/v5.4.0/inst/ddl/5.4/postgresql/OMOPCDM_postgresql_5.4_constraints.sql.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#always-close-the-connection",
    "href": "week2.html#always-close-the-connection",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.14 Always close the connection",
    "text": "3.14 Always close the connection\nWhen we’re done, it’s best to close the connection with dbDisconnect().\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#references",
    "href": "week2.html#references",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.15 References",
    "text": "3.15 References\n\n\nTidyexplain - All JOIN animations come from here.\n\nUnderstanding Joins - another nice visual explanation from R for Data Science.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html",
    "href": "miscellaneous.html",
    "title": "\n4  Miscellaneous Grabbag\n",
    "section": "",
    "text": "4.1 How to Store Passwords\nThis section is for small articles or to answer questions in class.\nA warning: do not store passwords in your code. It is a major security risk.\nThe key to avoiding this is to store the password where your machine can access it, but is not part of your code base. (If you are more advanced, you can store the password in your project directory, but make sure it is in your .gitignore).\nThere are multiple ways to store passwords securely:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#how-to-store-passwords",
    "href": "miscellaneous.html#how-to-store-passwords",
    "title": "\n4  Miscellaneous Grabbag\n",
    "section": "",
    "text": "Store them as an Environment Variable on your machine\nUse a global .Renviron file to store it outside of your code: https://rstats.wtf/r-startup.html#renviron\nStore them in a secure password manager / keyring (see below).\n\n\n4.1.1 What are environment variables?\nThese are variables that can be seen by all applications, including R/RStudio. They are not stored within code, but as variables in memory. One of the ones you might have had to struggle wiht is JAVA_HOME, whih is where you set a Java installation.\nWe can set environment variables directly, or we can specify them in a file called .Renviron that lives in our home directory.\nWe will use them as a more secure way to store our passwords. We choose the user scope so that it is saved in our home directory, not the project directory. This way, we can protect our password from prying eyes and bots.\n\nusethis::edit_r_environ(scope=\"user\")\n\n☐ Edit '/Users/tladera2/.Renviron'.\n\n\n☐ Restart R for changes to take effect.\n\n\nAdd the following to your .Renviron file:\nCLASS_DB_PASSWORD=\"IntroSQL\"\nYou may have to reopen the project for it to be loaded in your environment variables. We can now load the password using Sys.getenv().\n\nSys.getenv(\"CLASS_DB_PASSWORD\")\n\n[1] \"IntroSQL\"\n\n\nYou can also set the environment variable using Windows Control Panel or PowerShell: https://phoenixnap.com/kb/windows-set-environment-variable - the easiest way to do it is probably the control panel method.\nThere will probably be some sort of authentication process involved in connecting to your databases at Fred Hutch. I’ll add more info when I know more.\nThere is much more about storing passwords and other secrets such as API keys here: https://cran.r-project.org/web/packages/httr/vignettes/secrets.html.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#databases-versus-data-warehouses",
    "href": "miscellaneous.html#databases-versus-data-warehouses",
    "title": "\n4  Miscellaneous Grabbag\n",
    "section": "\n4.2 Databases versus Data Warehouses",
    "text": "4.2 Databases versus Data Warehouses\n\n\n\n\n\ngraph TD\n  A[(Database)] --ETL--&gt; D\n  B[(Database)] --ETL--&gt; D\n  C[(Database)] --ETL--&gt; D\n  D[(Data Warehouse)] \n\n\n\n\n\n\n\n\n\nDatabases: made for data collection, or transactional processing - these systems are made to be updated by multiple sources at once. For example, a collection form that feeds into a database can be submitted by multiple people at once. If you need the latest records, you want to pull from the database.\n\nData Warehouse: Aggregated data from many databases, made for data analysis, or analytical processing. They are usually updated on a nightly basis, taking summary data from each database.\n\nWe will be mostly doing analytical querying, as if our data is stored in a data warehouse.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#whats-the-deal-with-the-semicolon",
    "href": "miscellaneous.html#whats-the-deal-with-the-semicolon",
    "title": "\n4  Miscellaneous Grabbag\n",
    "section": "\n4.3 What’s the deal with the ; (semicolon)?",
    "text": "4.3 What’s the deal with the ; (semicolon)?\nWe use the ; to specify the end of a SQL statement. It is mostly important if you write SQL statements in multiple parts, which we will not do in class.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#keep-in-mind-beware-the-smart-quotes",
    "href": "miscellaneous.html#keep-in-mind-beware-the-smart-quotes",
    "title": "\n4  Miscellaneous Grabbag\n",
    "section": "\n4.4 Keep in Mind: Beware the Smart Quotes",
    "text": "4.4 Keep in Mind: Beware the Smart Quotes\nBeware cutting and pasting code from Microsoft Word\nMicrosoft products such as Word, will transform double quotes \" into what are called smart quotes: “”. This is bad for us, because it breaks our code.\n\"This is the Original String\"\nwill transform into:\n“This is the Original String”\nIt is very hard to see the difference between these, but if you cut and paste the bottom one (from a word document), your code will not run. That’s because the smart quotes aren’t double quotes, which you need to specify a string.\nJust be aware that you might have to fix these quotes if you’re cutting / pasting from a Microsoft product (although google is also guilty of this).\nOftentimes, you can disable this in Word/Google Docs, or be prepared to replace the smart quotes with double quotes. :::",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#dumping-a-query-straight-into-memory",
    "href": "miscellaneous.html#dumping-a-query-straight-into-memory",
    "title": "\n4  Miscellaneous Grabbag\n",
    "section": "\n4.5 Dumping a Query Straight into memory",
    "text": "4.5 Dumping a Query Straight into memory\n\nlibrary(duckdb)\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), \n                      \"data/GiBleed_5.3_1.1.duckdb\")\n\nWe can add a line to our SQL code cell to save the output of our SQL query\n```{sql}\n#| connection: \"con\"\n#| output.var: person\nSELECT * FROM person\n  LIMIT 10;\n```\nIf we run this, we will save the output into the object called person:\n\nSELECT * FROM person\n  LIMIT 10;\n\nWe can work with this as a normal R object now:\n\nperson\n\n   person_id gender_concept_id year_of_birth month_of_birth day_of_birth\n1          6              8532          1963             12           31\n2        123              8507          1950              4           12\n3        129              8507          1974             10            7\n4         16              8532          1971             10           13\n5         65              8532          1967              3           31\n6         74              8532          1972              1            5\n7         42              8532          1909             11            2\n8        187              8507          1945              7           23\n9         18              8532          1965             11           17\n10       111              8532          1975              5            2\n   birth_datetime race_concept_id ethnicity_concept_id location_id provider_id\n1      1963-12-31            8516                    0          NA          NA\n2      1950-04-12            8527                    0          NA          NA\n3      1974-10-07            8527                    0          NA          NA\n4      1971-10-13            8527                    0          NA          NA\n5      1967-03-31            8516                    0          NA          NA\n6      1972-01-05            8527                    0          NA          NA\n7      1909-11-02            8527                    0          NA          NA\n8      1945-07-23            8527                    0          NA          NA\n9      1965-11-17            8527                    0          NA          NA\n10     1975-05-02            8527                    0          NA          NA\n   care_site_id                  person_source_value gender_source_value\n1            NA 001f4a87-70d0-435c-a4b9-1425f6928d33                   F\n2            NA 052d9254-80e8-428f-b8b6-69518b0ef3f3                   M\n3            NA 054d32d5-904f-4df4-846b-8c08d165b4e9                   M\n4            NA 00444703-f2c9-45c9-a247-f6317a43a929                   F\n5            NA 02a3dad9-f9d5-42fb-8074-c16d45b4f5c8                   F\n6            NA 02fbf1be-29b7-4da8-8bbd-14c7433f843f                   F\n7            NA 0177d2e0-98f5-4f3d-bcfd-497b7a07b3f8                   F\n8            NA 07a1e14d-73ed-4d3a-9a39-d729745773fa                   M\n9            NA 0084b0fe-e30f-4930-b6d1-5e1eff4b7dea                   F\n10           NA 0478d6b3-bdb3-4574-9b93-cf448d725b84                   F\n   gender_source_concept_id race_source_value race_source_concept_id\n1                         0             black                      0\n2                         0             white                      0\n3                         0             white                      0\n4                         0             white                      0\n5                         0             black                      0\n6                         0             white                      0\n7                         0             white                      0\n8                         0             white                      0\n9                         0             white                      0\n10                        0             white                      0\n   ethnicity_source_value ethnicity_source_concept_id\n1             west_indian                           0\n2                 italian                           0\n3                  polish                           0\n4                american                           0\n5               dominican                           0\n6                 english                           0\n7                   irish                           0\n8                   irish                           0\n9                 english                           0\n10                english                           0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#query-plans",
    "href": "miscellaneous.html#query-plans",
    "title": "\n4  Miscellaneous Grabbag\n",
    "section": "\n4.6 Query Plans",
    "text": "4.6 Query Plans\nAll database systems will translate your SQL query into a concrete query plan: this shows step by step, how the engine will execute your query. With DuckDB, we can use EXPLAIN.\nNote that the output of EXPLAIN is not a table, which is why I’m using an R chunk to execute the SQL.\n\nstatement &lt;-   \"EXPLAIN SELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.procedure_date;\"\n\ndbGetQuery(con, statement)\n\nphysical_plan\n┌───────────────────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_decompress_integ│\n│     ral_integer(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│        ~38448 Rows        │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│          ORDER_BY         │\n│    ────────────────────   │\n│   po.procedure_date ASC   │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_compress_integra│\n│     l_usmallint(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│        ~38448 Rows        │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│         person_id         │\n│        concept_name       │\n│       procedure_date      │\n│                           │\n│        ~38448 Rows        │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         HASH_JOIN         │\n│    ────────────────────   │\n│      Join Type: INNER     │\n│                           │\n│        Conditions:        ├──────────────┐\n│   procedure_concept_id =  │              │\n│         concept_id        │              │\n│                           │              │\n│        ~38448 Rows        │              │\n└─────────────┬─────────────┘              │\n┌─────────────┴─────────────┐┌─────────────┴─────────────┐\n│         SEQ_SCAN          ││         SEQ_SCAN          │\n│    ────────────────────   ││    ────────────────────   │\n│           Table:          ││       Table: concept      │\n│    procedure_occurrence   ││    Type: Sequence Scan    │\n│                           ││                           │\n│    Type: Sequence Scan    ││        Projections:       │\n│                           ││         concept_id        │\n│        Projections:       ││        concept_name       │\n│    procedure_concept_id   ││                           │\n│         person_id         ││          Filters:         │\n│       procedure_date      ││  concept_id&gt;=4010253 AND  │\n│                           ││    concept_id&lt;=44805732   │\n│                           ││                           │\n│        ~37409 Rows        ││         ~444 Rows         │\n└───────────────────────────┘└───────────────────────────┘\n\n\nUsing EXPLAIN ANALYZE will not only show the query plan, but also how long it takes to execute each step.\n\nstatement &lt;-   \"EXPLAIN ANALYZE SELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.procedure_date;\"\n\ndbGetQuery(con, statement)\n\nanalyzed_plan\n┌─────────────────────────────────────┐\n│┌───────────────────────────────────┐│\n││    Query Profiling Information    ││\n│└───────────────────────────────────┘│\n└─────────────────────────────────────┘\nEXPLAIN ANALYZE SELECT po.person_id, c.concept_name, po.procedure_date     FROM procedure_occurrence as po      INNER JOIN concept as c     ON po.procedure_concept_id = c.concept_id     ORDER BY po.procedure_date;\n┌────────────────────────────────────────────────┐\n│┌──────────────────────────────────────────────┐│\n││              Total Time: 0.0034s             ││\n│└──────────────────────────────────────────────┘│\n└────────────────────────────────────────────────┘\n┌───────────────────────────┐\n│           QUERY           │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│      EXPLAIN_ANALYZE      │\n│    ────────────────────   │\n│           0 Rows          │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_decompress_integ│\n│     ral_integer(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│         37409 Rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│          ORDER_BY         │\n│    ────────────────────   │\n│   po.procedure_date ASC   │\n│                           │\n│         37409 Rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_compress_integra│\n│     l_usmallint(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│         37409 Rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│         person_id         │\n│        concept_name       │\n│       procedure_date      │\n│                           │\n│         37409 Rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         HASH_JOIN         │\n│    ────────────────────   │\n│      Join Type: INNER     │\n│                           │\n│        Conditions:        │\n│   procedure_concept_id =  ├──────────────┐\n│         concept_id        │              │\n│                           │              │\n│         37409 Rows        │              │\n│          (0.00s)          │              │\n└─────────────┬─────────────┘              │\n┌─────────────┴─────────────┐┌─────────────┴─────────────┐\n│         TABLE_SCAN        ││         TABLE_SCAN        │\n│    ────────────────────   ││    ────────────────────   │\n│           Table:          ││       Table: concept      │\n│    procedure_occurrence   ││    Type: Sequence Scan    │\n│                           ││                           │\n│    Type: Sequence Scan    ││        Projections:       │\n│                           ││         concept_id        │\n│        Projections:       ││        concept_name       │\n│    procedure_concept_id   ││                           │\n│         person_id         ││          Filters:         │\n│       procedure_date      ││  concept_id&gt;=4010253 AND  │\n│                           ││    concept_id&lt;=44805732   │\n│                           ││                           │\n│         37409 Rows        ││          235 Rows         │\n│          (0.00s)          ││          (0.00s)          │\n└───────────────────────────┘└───────────────────────────┘",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#apache-iceberg",
    "href": "miscellaneous.html#apache-iceberg",
    "title": "\n4  Miscellaneous Grabbag\n",
    "section": "\n4.7 Apache Iceberg",
    "text": "4.7 Apache Iceberg\nOne transactional database format that is starting to be very important is Apache Iceberg.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#how-do-we-speed-things-up",
    "href": "miscellaneous.html#how-do-we-speed-things-up",
    "title": "\n4  Miscellaneous Grabbag\n",
    "section": "\n4.8 How do we speed things up?",
    "text": "4.8 How do we speed things up?\nOur main tool for speeding up database searches is Indexing. Creating an index on a column speeds up searching through that particular column.\nDatabase Tuning is as much an art as it is a science. Too many indexes will make the database too big, whereas too few indexes will result in slow performance. This is why we hire database admins. Their work is incredibly important to keeping our data integrity and performing.\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Shannon, C. E. (1948). A Mathematical Theory of Communication. Bell System Technical Journal, 27(3), 379–423. https://ieeexplore.ieee.org/document/6773024\nTuring, A. M. (1950). Computing Machinery and Intelligence. Mind, 59(236), 433–460. https://mind.oxfordjournals.org/content/LIX/236/433\nTuring, A. M. (1936). On Computable Numbers, with an Application to the Entscheidungsproblem. Proceedings of the London Mathematical Society, s2-42(1), 230–265. https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf\nThompson, K. (1984). Reflections on Trusting Trust. Communications of the ACM, 27(8), 761–763. https://dl.acm.org/doi/10.1145/358198.358210\nGhemawat, S., Gobioff, H., & Leung, S.-T. (2003). The Google File System. In Proceedings of the Nineteenth ACM Symposium on Operating Systems Principles (pp. 29–43). https://research.google.com/archive/gfs-sosp2003.pdf",
    "crumbs": [
      "References"
    ]
  }
]