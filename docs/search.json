[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Intro to SQL",
    "section": "",
    "text": "Intro to SQL",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#course-description",
    "href": "index.html#course-description",
    "title": "Intro to SQL",
    "section": "Course Description",
    "text": "Course Description\nData that we need to utilize and query is often stored in data sources such as databases or data warehouses. In this course, you will learn how to connect and query databases using Structured Query Language (SQL). In particular, we will focus on querying data in a commonly used data model for storing patient data called OMOP. By the end of this course, you will be prepared to construct complex queries to retrieve large data sets and automate these queries to produce automated reports and dashboards.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "Intro to SQL",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nExplain data sources such as Databases and how to connect to them\nQuery data sources using database engines and Structured Query Language (SQL) to filter, join, and aggregate data\nConstruct and calculate new fields using SELECT or CASE WHEN\n(optional) Read and explain a sample OMOP query: https://github.com/OHDSI/OMOP-Queries/tree/master",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#instructors",
    "href": "index.html#instructors",
    "title": "Intro to SQL",
    "section": "Instructors",
    "text": "Instructors\nIf you need to schedule some time to talk, please schedule with Ted.\n\nTed Laderas, Director of Training and Community, Office of the Chief Data Officer\nVivek Sriram, Data Scientist, Office of the Chief Data Officer",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#introductions",
    "href": "index.html#introductions",
    "title": "Intro to SQL",
    "section": "Introductions",
    "text": "Introductions\nIn chat, please introduce yourself:\n\nYour Name & Your Group\nWhat you want to learn in this course\nFavorite Winter activity",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#tentative-schedule",
    "href": "index.html#tentative-schedule",
    "title": "Intro to SQL",
    "section": "Tentative Schedule",
    "text": "Tentative Schedule\nAll classes are on Fridays from 12:00-1:30 PM PST. Connection details will be provided. Office hours related to each class day are posted below, and the invite will be sent to you.\nIn class we will be going through the Quarto Notebooks that are hosted on Posit.cloud. No knowledge of R is necessary, we’ll show you what you need to know in class.\nClasses will be recorded, and those recordings will be sent to you after each class.\n\n\n\nWeek\nDate\nSubject\nOffice Hours\n\n\n\n\nPre-class\n—-\nConcepts of Databases\n\n\n\n1\nMay 8\nIntro to SQL; SHOW TABLES, DESCRIBE, SELECT, WHERE\nTBD\n\n\n2\nMay 15\nJOINing tables, more WHERE\nTBD\n\n\nhours\n\n\n\n\n\n3\nMay 22\nCalculating new fields, GROUP BY, CASE WHEN, HAVING\nTBD\n\n\n4\nMay 29\nSubqueries/Views, Recap of course / review OMOP queries\nTBD",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#format-of-class",
    "href": "index.html#format-of-class",
    "title": "Intro to SQL",
    "section": "Format of Class",
    "text": "Format of Class\nI will teach online only, though you have the option of attending in the DaSL Lounge (Arnold M1-B406), which will have snacks and drinks available. Either Chris Lo or Vivek Sriram will host in person.\nWe will spend the first 20-25 minutes of each class on catching up on last week’s exercises if you haven’t had the opportunity to work on them. Followed by that, we will have a short lecture/lab, where we will go through the notebooks for the week.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#first-class-survey",
    "href": "index.html#first-class-survey",
    "title": "Intro to SQL",
    "section": "First Class Survey",
    "text": "First Class Survey\nFirst Class Survey - Please fill out. We mostly want to see how confident you are before and after class. We will share these results with everyone (anonymized).",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#weekly-check-in",
    "href": "index.html#weekly-check-in",
    "title": "Intro to SQL",
    "section": "Weekly Check In",
    "text": "Weekly Check In\nWeekly Check In Form - please fill out to let us know if you have any issues or want to share what you’ve learned. We look at the answers in aggregate and we anonymize responses (unless you want us to know).",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#posit-cloud-intro",
    "href": "index.html#posit-cloud-intro",
    "title": "Intro to SQL",
    "section": "Posit Cloud Intro",
    "text": "Posit Cloud Intro\nHere is a short video introducing you to the Posit Cloud interface.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#culture-of-the-course",
    "href": "index.html#culture-of-the-course",
    "title": "Intro to SQL",
    "section": "Culture of the course",
    "text": "Culture of the course\n\nLearning on the job is challenging\n\nI will move at learner’s pace; we are learning together.\nTeach not for mastery, but teach for empowerment to learn effectively.\n\n\nWe sometimes struggle with our data science in isolation, unaware that someone two doors down from us has gone through the same struggle.\n\nWe learn and work better with our peers.\nKnow that if you have a question, other people will have it.\nAsking questions is our way of taking care of others.\n\nWe ask you to follow Participation Guidelines and Code of Conduct.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#posit-cloud-project",
    "href": "index.html#posit-cloud-project",
    "title": "Intro to SQL",
    "section": "Posit Cloud Project",
    "text": "Posit Cloud Project\nFor those who are not Fred Hutch learners and want to try the course out, we have an Posit.cloud Project that you can clone to your own account: https://posit.cloud/content/10022544",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#badge-of-completion",
    "href": "index.html#badge-of-completion",
    "title": "Intro to SQL",
    "section": "Badge of completion",
    "text": "Badge of completion\n\nWe offer a badge of completion when you finish the course!\nWhat it is:\n\nA display of what you accomplished in the course, shareable in your professional networks such as LinkedIn, similar to online education services such as Coursera.\n\nWhat it isn’t:\n\nAccreditation through an university or degree-granting program.\n\nRequirements:\n\nComplete badge-required sections of the exercises for 3 out of 4 assignments. We’ll cover this in class",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "index.html#available-course-formats",
    "href": "index.html#available-course-formats",
    "title": "Intro to SQL",
    "section": "Available Course Formats",
    "text": "Available Course Formats\nThis course is available in multiple formats which allows you to take it in the way that best suites your needs.\n\nThe material for this course can be viewed without login requirement on this website. This format might be most appropriate for you if you rely on screen-reader technology.\nThe material is also available to Fred Hutch Consortia students via Posit Cloud.\nOur courses are open source, you can find the source material for this course on GitHub.",
    "crumbs": [
      "Intro to SQL"
    ]
  },
  {
    "objectID": "concepts.html",
    "href": "concepts.html",
    "title": "\n1  Database Concepts\n",
    "section": "",
    "text": "1.1 What is a Database?\nWhen we talk about databases, we mean the database system rather than database itself. Specifically, we talk about the different layers of a database system.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#what-is-a-database",
    "href": "concepts.html#what-is-a-database",
    "title": "\n1  Database Concepts\n",
    "section": "",
    "text": "A database is an organized collection of structured information, or data, typically stored electronically in a computer system. A database is usually controlled by a database management system (DBMS). Together, the data and the DBMS, along with the applications that are associated with them, are referred to as a database system, often shortened to just database. - Oracle Documentation",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#parts-of-a-database-system",
    "href": "concepts.html#parts-of-a-database-system",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.2 Parts of a Database System",
    "text": "1.2 Parts of a Database System\nThe Composable Codex talks about three layers of a database system:\nFrom the Composable Codex\n\n\nA user interface - how users interact with the database. In this class, our main way of interacting with databases is SQL (Structured Query Language).\n\nAn execution engine - a software system that queries the data in storage. There are many examples of this: SQL Server, MariaDB, DuckDB, Snowflake. These can live on our machine, on a server within our network, or a server on the cloud.\n\nData Storage - the physical location where the data is stored. This could be on your computer, on the network, or in the cloud (such as an Amazon S3 bucket)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#for-this-class",
    "href": "concepts.html#for-this-class",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.3 For this class",
    "text": "1.3 For this class\nIn our class, we will use the following configuration:\n\n\n\n\n\ngraph TD\nA[\"1.SQL\"] --&gt; B\nB[\"2.DuckDB\"] --&gt; C\nC[\"3.File on our Machine\"]\n\n\n\n\n\n\n\n\n\n\n\n\nWhy We’re Using DuckDB in this Course\n\n\n\nDuckDB is a very fast, open-source database engine. Because of restrictions on clinical data, sometimes the only way to analyze it is on an approved laptop. DuckDB does wondrous things on laptops, so we hope it will be a helpful tool in your arsenal.\nIt is what is called an analytical database engine, which means it is very fast for reading and querying data. This is compared to a transactional database engine, which must handle multiple users interacting and inserting data into the database at once.\n\n\nBut you can think of other configurations that might be more applicable to you. For example, a lot of groups at the Hutch use SQL Server:\n\n\n\n\n\ngraph TD\nA[\"1.SQL\"] --&gt; B\nB[\"2.SQL Server\"] --&gt; C\nC[\"3.FH Shared Storage\"]\n\n\n\n\n\n\nIn many ways, SQL Server and its storage are tightly coupled (the engine and the storage are in the same location). This coupling can make it difficult to migrate out of such systems.\nOr, for those who want to use cloud-based systems, we can have this configuration:\n\n\n\n\n\ngraph TD\nA[\"1.SQL/Notebooks\"] --&gt; B\nB[\"2.Databricks/Snowflake\"] --&gt; C\nC[\"3.Amazon S3\"]\n\n\n\n\n\n\nIn this case, we need to sign into the Databricks system, which is a set of systems that lives in the cloud. We actually will use SQL within their notebooks to write our queries. Databricks will then use the Snowflake engine to query the data that is stored in cloud storage (an S3 bucket).\nIf this is making you dizzy, don’t worry too much about it. Just know that we can switch out the different layers based on our needs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#what-is-sql",
    "href": "concepts.html#what-is-sql",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.4 What is SQL?",
    "text": "1.4 What is SQL?\nSQL is short for Structured Query Language. It is a standardized language for querying databases (originally relational databases)\nSQL lets us do various operations on data. It contains various clauses which let us manipulate data:\n\n\n\n\n\n\n\nPriority\nClause\nPurpose\n\n\n\n1\nFROM\nChoose tables to query and specify how to JOIN them together\n\n\n2\nWHERE\nFilter tables based on criteria\n\n\n3\nGROUP BY\nAggregates the Data\n\n\n4\nHAVING\nFilters Aggregated Data\n\n\n5\nSELECT\nSelects columns in table and calculate new columns\n\n\n6\nORDER BY\nSorts by a database field\n\n\n7\nLIMIT\nLimits the number of records returned\n\n\n\nWe do not use all of these clauses when we write a SQL Query. We only use the ones we need to get the data we need out.\nOftentimes, we really only want a summary out of the database. We would probably use the following clauses:\n\n\n\n\n\n\n\nPriority\nClause\nPurpose\n\n\n\n1\nFROM\nChoose tables to query and specify how to JOIN them together\n\n\n2\nWHERE\nFilter tables based on criteria\n\n\n3\nGROUP BY\nAggregates the Data\n\n\n5\nSELECT\nSelects columns in table and calculate new columns\n\n\n\nNotice that there is a Priority column in these tables. This is important, because parts of queries are evaluated in this order.\n\n\n\n\n\n\nDialects of SQL\n\n\n\nYou may have heard that the SQL used in SQL Server is different than other databases. In truth, there are multiple dialects of SQL, based on the engine.\nHowever, we’re focusing on the 95% of SQL that is common to all systems. Most of the time, the SQL we’re showing you in this course will get you to where you want to go.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#anatomy-of-a-sql-statement",
    "href": "concepts.html#anatomy-of-a-sql-statement",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.5 Anatomy of a SQL Statement",
    "text": "1.5 Anatomy of a SQL Statement\nLet’s look at a typical SQL statement:\nSELECT person_id, gender_source_value   # Choose Columns\n  FROM person                           # Choose the person table\n  WHERE year_of_birth &lt; 2000;            # Filter the data using a criterion\nWe can read this as:\nSELECT the person_id and gender_source_value columns\nFROM the person table\nONLY Those with year of birth less than 2000 \nAs you can see, SQL can be read. We will gradually introduce clauses and different database operations.\n\n\n\n\n\n\nNote\n\n\n\nAs a convention, we will capitalize SQL clauses (such as SELECT), and use lowercase for everything else.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#database-connections",
    "href": "concepts.html#database-connections",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.6 Database Connections",
    "text": "1.6 Database Connections\nWe haven’t really talked about how we connect to the database engine.\nIn order to connect to the database engine and create a database connection, we may have to authenticate with an ID/password combo or use other methods of authentication to prove who we are.\nOnce we are authenticated, we now have a connection. This is basically our conduit to the database engine. We can send queries through it, and the database engine will run these queries, and return a result.\n\n\n\n\n\ngraph LR\n  A[\"Our Computer\"] --query--&gt; B[Database Engine]\n  B --results--&gt; A\n\n\n\n\n\n\nAs long as the connection is open, we can continue to send queries and receive results.\nIt is best practice to explicitly disconnect from the database. Once we have disconnected, we no longer have access to the database.\n\n\n\n\n\ngraph LR\n  A[\"Our Computer\"] --X--&gt; B[Database Engine]\n  B --X--&gt; A",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "concepts.html#how-is-the-data-stored",
    "href": "concepts.html#how-is-the-data-stored",
    "title": "\n1  Database Concepts\n",
    "section": "\n1.7 How is the Data Stored?",
    "text": "1.7 How is the Data Stored?\nTypically, the data in databases is stored in tables, such as the one below:\n\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nperson_id\ngender_concept_id\nyear_of_birth\nmonth_of_birth\nday_of_birth\nbirth_datetime\nrace_concept_id\nethnicity_concept_id\nlocation_id\nprovider_id\ncare_site_id\nperson_source_value\ngender_source_value\ngender_source_concept_id\nrace_source_value\nrace_source_concept_id\nethnicity_source_value\nethnicity_source_concept_id\n\n\n\n6\n8532\n1963\n12\n31\n1963-12-31\n8516\n0\nNA\nNA\nNA\n001f4a87-70d0-435c-a4b9-1425f6928d33\nF\n0\nblack\n0\nwest_indian\n0\n\n\n123\n8507\n1950\n4\n12\n1950-04-12\n8527\n0\nNA\nNA\nNA\n052d9254-80e8-428f-b8b6-69518b0ef3f3\nM\n0\nwhite\n0\nitalian\n0\n\n\n129\n8507\n1974\n10\n7\n1974-10-07\n8527\n0\nNA\nNA\nNA\n054d32d5-904f-4df4-846b-8c08d165b4e9\nM\n0\nwhite\n0\npolish\n0\n\n\n16\n8532\n1971\n10\n13\n1971-10-13\n8527\n0\nNA\nNA\nNA\n00444703-f2c9-45c9-a247-f6317a43a929\nF\n0\nwhite\n0\namerican\n0\n\n\n65\n8532\n1967\n3\n31\n1967-03-31\n8516\n0\nNA\nNA\nNA\n02a3dad9-f9d5-42fb-8074-c16d45b4f5c8\nF\n0\nblack\n0\ndominican\n0\n\n\n74\n8532\n1972\n1\n5\n1972-01-05\n8527\n0\nNA\nNA\nNA\n02fbf1be-29b7-4da8-8bbd-14c7433f843f\nF\n0\nwhite\n0\nenglish\n0\n\n\n42\n8532\n1909\n11\n2\n1909-11-02\n8527\n0\nNA\nNA\nNA\n0177d2e0-98f5-4f3d-bcfd-497b7a07b3f8\nF\n0\nwhite\n0\nirish\n0\n\n\n187\n8507\n1945\n7\n23\n1945-07-23\n8527\n0\nNA\nNA\nNA\n07a1e14d-73ed-4d3a-9a39-d729745773fa\nM\n0\nwhite\n0\nirish\n0\n\n\n18\n8532\n1965\n11\n17\n1965-11-17\n8527\n0\nNA\nNA\nNA\n0084b0fe-e30f-4930-b6d1-5e1eff4b7dea\nF\n0\nwhite\n0\nenglish\n0\n\n\n111\n8532\n1975\n5\n2\n1975-05-02\n8527\n0\nNA\nNA\nNA\n0478d6b3-bdb3-4574-9b93-cf448d725b84\nF\n0\nwhite\n0\nenglish\n0\n\n\n\n\n\nSome quick terminology:\n\n\nDatabase Record - a row in this table. In this case, each row in the table above corresponds to a single person.\n\nDatabase Field - the columns in this table. In our case, each column corresponds to a single measurement, such as birth_datetime. Each column has a specific datatype, which may be integers, decimals, dates, a short text field, or longer text fields. Think of them like the different pieces of information requested in a form.\n\nIt is faster and requires less memory if we do not use a single large table, but decompose the data up into multiple tables. These tables are stored in a number of different formats:\n\nComma Separated Value (CSV)\nA Single File (SQL Server)\na virtual file\n\n\nIn a virtual file, the data acts like it is stored in a single file, but is actually many different files underneath that can be on your machine, on the network, or on the cloud. The virtual file lets us interact with this large mass of data as if it is a single file.\nThe database engine is responsible for scanning the data, either row by row, or column by column. The engines are made to be very fast in this scanning to return relevant records.\n\n\n\n\n\n\nRows versus Columns\n\n\n\nJust a quick note about row-based storage vs column-based storage. SQL was originally written for relational databases, which are stored by row.\nA new trick is column-based storage. It turns out that it’s actually faster to query the data in many instances when the data in a column is all stored together. These are the formats like Parquet that you might have heard about. A lot of newer database engines rely on the data to be stored in this format.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Database Concepts</span>"
    ]
  },
  {
    "objectID": "week1.html",
    "href": "week1.html",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "",
    "text": "2.1 Our Composable Database System",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#our-composable-database-system",
    "href": "week1.html#our-composable-database-system",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "",
    "text": "Client: R/RStudio w/ SQL\nDatabase Engine: DuckDB\nData Storage: single file in data/ folder",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#connecting-to-our-database",
    "href": "week1.html#connecting-to-our-database",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.2 Connecting to our database",
    "text": "2.2 Connecting to our database\nTo access the data, we need to create a database connection. We use dbConnect() from the DBI package to do this. The first argument specifies the Database engine (duckdb()), and the second provides the file location: \"data/data/GiBleed_5.3_1.1.duckdb\".\n\nlibrary(duckdb)\n\nLoading required package: DBI\n\nlibrary(DBI)\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), \n                      \"data/GiBleed_5.3_1.1.duckdb\")\n\nOnce open, we can use con (our database connection)\n\n\n\n\n\n\nKeep in Mind: SQL ignores letter case\n\n\n\nThese are the same to the database engine:\nSELECT person_id FROM person;\nselect PERSON_ID FROM person;\nAnd so on. Our convention is that we capitalize SQL clauses such as SELECT so you can differentiate them from other information.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#looking-at-the-entire-database",
    "href": "week1.html#looking-at-the-entire-database",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.3 Looking at the Entire Database",
    "text": "2.3 Looking at the Entire Database\nOne of the first things we can learn is to show the contents of the entire database; we can do this with SHOW TABLES:\n\nSHOW TABLES;\n\n\nDisplaying records 1 - 10\n\nname\n\n\n\ncare_site\n\n\ncdm_source\n\n\nconcept\n\n\nconcept_ancestor\n\n\nconcept_class\n\n\nconcept_relationship\n\n\nconcept_synonym\n\n\ncondition_era\n\n\ncondition_occurrence\n\n\ncost\n\n\n\n\n\nWe can get further information about the tables within our database using DESCRIBE; This will give us more information about individual tables:\n\nDESCRIBE;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\ndatabase\nschema\nname\ncolumn_names\ncolumn_types\ntemporary\n\n\n\nGiBleed_5\nmain\ncare_site\ncare_site_id , care_site_name , place_of_service_concept_id , location_id , care_site_source_value , place_of_service_source_value\nINTEGER, VARCHAR, INTEGER, INTEGER, VARCHAR, VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\ncdm_source\ncdm_source_name , cdm_source_abbreviation , cdm_holder , source_description , source_documentation_reference, cdm_etl_reference , source_release_date , cdm_release_date , cdm_version , vocabulary_version\nVARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, DATE , DATE , VARCHAR, VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\nconcept\nconcept_id , concept_name , domain_id , vocabulary_id , concept_class_id, standard_concept, concept_code , valid_start_date, valid_end_date , invalid_reason\nINTEGER, VARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, VARCHAR, DATE , DATE , VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\nconcept_ancestor\nancestor_concept_id , descendant_concept_id , min_levels_of_separation, max_levels_of_separation\nINTEGER, INTEGER, INTEGER, INTEGER\nFALSE\n\n\nGiBleed_5\nmain\nconcept_class\nconcept_class_id , concept_class_name , concept_class_concept_id\nVARCHAR, VARCHAR, INTEGER\nFALSE\n\n\nGiBleed_5\nmain\nconcept_relationship\nconcept_id_1 , concept_id_2 , relationship_id , valid_start_date, valid_end_date , invalid_reason\nINTEGER, INTEGER, VARCHAR, DATE , DATE , VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\nconcept_synonym\nconcept_id , concept_synonym_name, language_concept_id\nINTEGER, VARCHAR, INTEGER\nFALSE\n\n\nGiBleed_5\nmain\ncondition_era\ncondition_era_id , person_id , condition_concept_id , condition_era_start_date , condition_era_end_date , condition_occurrence_count\nINTEGER, INTEGER, INTEGER, DATE , DATE , INTEGER\nFALSE\n\n\nGiBleed_5\nmain\ncondition_occurrence\ncondition_occurrence_id , person_id , condition_concept_id , condition_start_date , condition_start_datetime , condition_end_date , condition_end_datetime , condition_type_concept_id , condition_status_concept_id , stop_reason , provider_id , visit_occurrence_id , visit_detail_id , condition_source_value , condition_source_concept_id , condition_status_source_value\nINTEGER , INTEGER , INTEGER , DATE , TIMESTAMP, DATE , TIMESTAMP, INTEGER , INTEGER , VARCHAR , INTEGER , INTEGER , INTEGER , VARCHAR , INTEGER , VARCHAR\nFALSE\n\n\nGiBleed_5\nmain\ncost\ncost_id , cost_event_id , cost_domain_id , cost_type_concept_id , currency_concept_id , total_charge , total_cost , total_paid , paid_by_payer , paid_by_patient , paid_patient_copay , paid_patient_coinsurance , paid_patient_deductible , paid_by_primary , paid_ingredient_cost , paid_dispensing_fee , payer_plan_period_id , amount_allowed , revenue_code_concept_id , revenue_code_source_value, drg_concept_id , drg_source_value\nINTEGER, INTEGER, VARCHAR, INTEGER, INTEGER, FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , FLOAT , INTEGER, FLOAT , INTEGER, VARCHAR, INTEGER, VARCHAR\nFALSE\n\n\n\n\n\nWe’ll look at a few tables in our work:\n\n\nperson - Contains personal & demographic data\n\nprocedure_occurrence - procedures performed on patients and when they happened\n\ncondition_occurrence - patient conditions (such as illnesses) and when they occurred\n\nconcept - contains the specific information (names of concepts) that map into all three above tables\n\nWe’ll talk much more later about the relationships between these tables.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#select-and-from",
    "href": "week1.html#select-and-from",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.4 SELECT and FROM\n",
    "text": "2.4 SELECT and FROM\n\nIf we want to see the contents of a table, we can use SELECT and FROM.\nSELECT *          # select all columns\n  FROM person     # from the person table\n  LIMIT 10;       # return only 10 rows\n\nSELECT * FROM person LIMIT 10;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nperson_id\ngender_concept_id\nyear_of_birth\nmonth_of_birth\nday_of_birth\nbirth_datetime\nrace_concept_id\nethnicity_concept_id\nlocation_id\nprovider_id\ncare_site_id\nperson_source_value\ngender_source_value\ngender_source_concept_id\nrace_source_value\nrace_source_concept_id\nethnicity_source_value\nethnicity_source_concept_id\n\n\n\n6\n8532\n1963\n12\n31\n1963-12-31\n8516\n0\nNA\nNA\nNA\n001f4a87-70d0-435c-a4b9-1425f6928d33\nF\n0\nblack\n0\nwest_indian\n0\n\n\n123\n8507\n1950\n4\n12\n1950-04-12\n8527\n0\nNA\nNA\nNA\n052d9254-80e8-428f-b8b6-69518b0ef3f3\nM\n0\nwhite\n0\nitalian\n0\n\n\n129\n8507\n1974\n10\n7\n1974-10-07\n8527\n0\nNA\nNA\nNA\n054d32d5-904f-4df4-846b-8c08d165b4e9\nM\n0\nwhite\n0\npolish\n0\n\n\n16\n8532\n1971\n10\n13\n1971-10-13\n8527\n0\nNA\nNA\nNA\n00444703-f2c9-45c9-a247-f6317a43a929\nF\n0\nwhite\n0\namerican\n0\n\n\n65\n8532\n1967\n3\n31\n1967-03-31\n8516\n0\nNA\nNA\nNA\n02a3dad9-f9d5-42fb-8074-c16d45b4f5c8\nF\n0\nblack\n0\ndominican\n0\n\n\n74\n8532\n1972\n1\n5\n1972-01-05\n8527\n0\nNA\nNA\nNA\n02fbf1be-29b7-4da8-8bbd-14c7433f843f\nF\n0\nwhite\n0\nenglish\n0\n\n\n42\n8532\n1909\n11\n2\n1909-11-02\n8527\n0\nNA\nNA\nNA\n0177d2e0-98f5-4f3d-bcfd-497b7a07b3f8\nF\n0\nwhite\n0\nirish\n0\n\n\n187\n8507\n1945\n7\n23\n1945-07-23\n8527\n0\nNA\nNA\nNA\n07a1e14d-73ed-4d3a-9a39-d729745773fa\nM\n0\nwhite\n0\nirish\n0\n\n\n18\n8532\n1965\n11\n17\n1965-11-17\n8527\n0\nNA\nNA\nNA\n0084b0fe-e30f-4930-b6d1-5e1eff4b7dea\nF\n0\nwhite\n0\nenglish\n0\n\n\n111\n8532\n1975\n5\n2\n1975-05-02\n8527\n0\nNA\nNA\nNA\n0478d6b3-bdb3-4574-9b93-cf448d725b84\nF\n0\nwhite\n0\nenglish\n0\n\n\n\n\n\n\nWhy are there birth_datetime and the month_of_birth, day_of_birth, year_of_birth - aren’t these redundant?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#try-it-out",
    "href": "week1.html#try-it-out",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.5 Try it Out",
    "text": "2.5 Try it Out\nLook at the first few rows of procedure_occurrence.\n\nSELECT * FROM ____ LIMIT 10;\n\n\nWhy is there a person_id column in this table as well?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#selecting-a-few-columns-in-our-table",
    "href": "week1.html#selecting-a-few-columns-in-our-table",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.6 SELECTing a few columns in our table",
    "text": "2.6 SELECTing a few columns in our table\nWe can use the SELECT clause to grab specific columns in our data.\nSELECT person_id, birth_datetime, gender_concept_id # Columns in our table\n  FROM person;                                      # Our Table\n\nSELECT person_id, birth_datetime, gender_concept_id \n  FROM person\n  LIMIT 10;\n\n\nDisplaying records 1 - 10\n\nperson_id\nbirth_datetime\ngender_concept_id\n\n\n\n6\n1963-12-31\n8532\n\n\n123\n1950-04-12\n8507\n\n\n129\n1974-10-07\n8507\n\n\n16\n1971-10-13\n8532\n\n\n65\n1967-03-31\n8532\n\n\n74\n1972-01-05\n8532\n\n\n42\n1909-11-02\n8532\n\n\n187\n1945-07-23\n8507\n\n\n18\n1965-11-17\n8532\n\n\n111\n1975-05-02\n8532",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#try-it-out-1",
    "href": "week1.html#try-it-out-1",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.7 Try it Out",
    "text": "2.7 Try it Out\nWhat happens if we ask for a column that doesn’t exist in our data?\n\nSELECT person_id, birth_datetime, gender_concept_id, blah\n  FROM person;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#check-on-learning",
    "href": "week1.html#check-on-learning",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.8 Check on Learning",
    "text": "2.8 Check on Learning\nAdd race_concept_id and year_of_birth to your SELECT query:\n\nSELECT person_id, birth_datetime, gender_concept_id, ____, ____\n  FROM person;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#where---filtering-our-table",
    "href": "week1.html#where---filtering-our-table",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.9 WHERE - filtering our table",
    "text": "2.9 WHERE - filtering our table\nAdding WHERE to our SQL statement lets us add filtering to our query:\n\nSELECT person_id, gender_source_value, race_source_value, year_of_birth \n  FROM person \n  WHERE year_of_birth &lt; 1980\n\n\nDisplaying records 1 - 10\n\nperson_id\ngender_source_value\nrace_source_value\nyear_of_birth\n\n\n\n6\nF\nblack\n1963\n\n\n123\nM\nwhite\n1950\n\n\n129\nM\nwhite\n1974\n\n\n16\nF\nwhite\n1971\n\n\n65\nF\nblack\n1967\n\n\n74\nF\nwhite\n1972\n\n\n42\nF\nwhite\n1909\n\n\n187\nM\nwhite\n1945\n\n\n18\nF\nwhite\n1965\n\n\n111\nF\nwhite\n1975\n\n\n\n\n\nOne critical thing to know is that you don’t need to include the columns you’re filtering on in the SELECT part of the statement. For example, we could do the following as well, removing year_of_birth from our SELECT:\n\nSELECT person_id, gender_source_value, race_source_value \n  FROM person \n  WHERE year_of_birth &lt; 2000\n\n\nDisplaying records 1 - 10\n\nperson_id\ngender_source_value\nrace_source_value\n\n\n\n6\nF\nblack\n\n\n123\nM\nwhite\n\n\n129\nM\nwhite\n\n\n16\nF\nwhite\n\n\n65\nF\nblack\n\n\n74\nF\nwhite\n\n\n42\nF\nwhite\n\n\n187\nM\nwhite\n\n\n18\nF\nwhite\n\n\n111\nF\nwhite\n\n\n\n\n\n\n2.9.1 Single quotes and WHERE\n\nSQL convention: single quotes (‘M’) refer to values, and double quotes refer to columns (“person_id”). If you try to use double quotes in the below, it will look for a column called “M”.\nThis will trip you up several times if you’re not used to it.\n\nSELECT person_id, gender_source_value, race_source_value \n  FROM person \n  WHERE gender_source_value = 'M'\n  LIMIT 10;\n\n\nDisplaying records 1 - 10\n\nperson_id\ngender_source_value\nrace_source_value\n\n\n\n123\nM\nwhite\n\n\n129\nM\nwhite\n\n\n187\nM\nwhite\n\n\n40\nM\nwhite\n\n\n53\nM\nwhite\n\n\n78\nM\nwhite\n\n\n69\nM\nasian\n\n\n248\nM\nwhite\n\n\n105\nM\nwhite\n\n\n49\nM\nwhite\n\n\n\n\n\nReminder: use single (’’) quotes in your SQL statements to refer to values, not double quotes (“).\n\n\n\n\n\n\nQuick Note\n\n\n\nFor R users, notice the similarity of select() with SELECT. We can rewrite the above in dplyr code as:\nperson |&gt;\n  select(person_id, gender_source_value, race_source_value)\nA lot of dplyr was inspired by SQL. In fact, there is a package called dbplyr that translates dplyr statements into SQL. A lot of us use it, and it’s pretty handy.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#count---how-many-rows",
    "href": "week1.html#count---how-many-rows",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.10 COUNT - how many rows?",
    "text": "2.10 COUNT - how many rows?\nSometimes you want to know the size of your result, not necessarily return the entire set of results. That is what COUNT is for.\n\nSELECT COUNT(*) \n  FROM person\n  WHERE year_of_birth &lt; 2000;\n\n\n1 records\n\ncount_star()\n\n\n2694\n\n\n\n\nSimilarly, when we want to count the number of person_ids returned, we can use COUNT(person_id):\n\nSELECT COUNT(person_id) \n  FROM person\n  WHERE year_of_birth &lt; 2000;\n\n\n1 records\n\ncount(person_id)\n\n\n2694\n\n\n\n\nLet’s switch gears to the procedure_concept_id table. Let’s count the overall number of procedure_concept_ids in our table:\n\nSELECT COUNT(procedure_concept_id)\n  FROM procedure_occurrence;\n\n\n1 records\n\ncount(procedure_concept_id)\n\n\n37409\n\n\n\n\nHmmm. That’s quite a lot, but are there repeat procedure_concept_ids?\nWhen you have repeated values in the rows, COUNT(DISTINCT ) can help you find the number of unique values in a column:\n\nSELECT COUNT(DISTINCT procedure_concept_id)\n  FROM procedure_occurrence\n\n\n1 records\n\ncount(DISTINCT procedure_concept_id)\n\n\n51\n\n\n\n\nWe can also return the actual DISTINCT values by removing COUNT:\n\nSELECT DISTINCT procedure_concept_id\n  FROM procedure_occurrence;\n\n\nDisplaying records 1 - 10\n\nprocedure_concept_id\n\n\n\n4058899\n\n\n4295880\n\n\n4216130\n\n\n4024289\n\n\n4202451\n\n\n4330583\n\n\n4238715\n\n\n4186930\n\n\n4242997\n\n\n4078793",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#check-on-learning-1",
    "href": "week1.html#check-on-learning-1",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.11 Check on Learning",
    "text": "2.11 Check on Learning\nCount the distinct values of gender_source_value in person:\n\nSELECT COUNT(DISTINCT --------------)\n  FROM -------;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#keys-linking-tables-together",
    "href": "week1.html#keys-linking-tables-together",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.12 Keys: Linking tables together",
    "text": "2.12 Keys: Linking tables together\nOne of the important properties of data in a relational database is that there are no repeat rows in the database. Each table that meets this restriction has what is called a primary key.\nWe can use DESCRIBE to get more information (the metadata) about a table. This gives us information about our tables.\n\nDESCRIBE person\n\n\nDisplaying records 1 - 10\n\ncolumn_name\ncolumn_type\nnull\nkey\ndefault\nextra\n\n\n\nperson_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\ngender_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nyear_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nmonth_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nday_of_birth\nINTEGER\nYES\nNA\nNA\nNA\n\n\nbirth_datetime\nTIMESTAMP\nYES\nNA\nNA\nNA\n\n\nrace_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nethnicity_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nlocation_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprovider_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\n\n\n\nScanning the rows, which field/column is the primary key for person?\nTry and find the primary key for procedure_occurrence. What is it?\n\nDESCRIBE procedure_occurrence\n\n\nDisplaying records 1 - 10\n\ncolumn_name\ncolumn_type\nnull\nkey\ndefault\nextra\n\n\n\nprocedure_occurrence_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nperson_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprocedure_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprocedure_date\nDATE\nYES\nNA\nNA\nNA\n\n\nprocedure_datetime\nTIMESTAMP\nYES\nNA\nNA\nNA\n\n\nprocedure_type_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nmodifier_concept_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nquantity\nINTEGER\nYES\nNA\nNA\nNA\n\n\nprovider_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\nvisit_occurrence_id\nINTEGER\nYES\nNA\nNA\nNA\n\n\n\n\n\nWe’ll see that keys need to be unique (so they can map to each row). In fact, each key is a way to connect one table to another.\nWhat column is the same in both tables? That is a hint for what we’ll cover next week: JOINing tables.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#data-types",
    "href": "week1.html#data-types",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.13 Data Types",
    "text": "2.13 Data Types\nIf you look at the column_type for one of the DESCRIBE statements above, you’ll notice there are different data types:\n\nINTEGER\nTIMESTAMP\nDATE\nVARCHAR\n\nEach column of a database needs to be typed. The data type of a column determines what kinds of calculations or operations we can do on them. For example, we can do things like date arithmetic on DATETIME columns, asking the engine to calculate 5 days after the dates.\nYou can see all of the datatypes that are available in DuckDB here.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week1.html#always-close-the-connection",
    "href": "week1.html#always-close-the-connection",
    "title": "\n2  Week 1: DESCRIBE, SELECT, WHERE\n",
    "section": "\n2.14 Always close the connection",
    "text": "2.14 Always close the connection\nWhen we’re done, it’s best to close the connection with dbDisconnect().\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1: `DESCRIBE`, `SELECT`, `WHERE`</span>"
    ]
  },
  {
    "objectID": "week2.html",
    "href": "week2.html",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "",
    "text": "3.1 Connecting to our database\nLet’s connect to our database.\nlibrary(duckdb)\n\nLoading required package: DBI\n\nlibrary(DBI)\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), \n                      \"data/GiBleed_5.3_1.1.duckdb\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#table-references",
    "href": "week2.html#table-references",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.2 Table References",
    "text": "3.2 Table References\nIn single table queries, it is usually unambiguous to the query engine which column and which table you need to query.\nHowever, when you involve multiple tables, it is important to know how to refer to a column in a specific table.\nFor example, the procedure_occurrence table has a person_id column as well. If we want to use this specific column in this table, we can use the . (dot) notation:\nprocedure_occurrence.person_id\nIf we wanted the person_id column in person we can use this:\nperson.person_id\nThis will become much more important as we get into JOINing tables.\n\n3.2.1 Check on Learning\nAdd table references to the WHERE part of the query:\n\nSELECT *\n  FROM procedure_occurrence\n  WHERE person_id = 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#aliases",
    "href": "week2.html#aliases",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.3 Aliases",
    "text": "3.3 Aliases\nAs your queries get more complex, and as you involve more and more tables, you will need to use aliases. I think of them like “nicknames” - they can save you a lot of typing.\nI tend to use the AS clause when I define them. I’ve used AS here to abbreviate person. I use it in two different places: in my COUNT, and in my WHERE:\n\nSELECT COUNT(p.person_id)\n  FROM person AS p\n  WHERE p.year_of_birth &lt; 2000;\n\n\n1 records\n\ncount(p.person_id)\n\n\n2694\n\n\n\n\nSome people don’t use AS, just putting the aliases next to the original name:\n\nSELECT COUNT(p.person_id)\n  FROM person p\n  WHERE p.year_of_birth &lt; 2000;\n\n\n1 records\n\ncount(p.person_id)\n\n\n2694\n\n\n\n\nWe can also rename variables using AS:\n\nSELECT COUNT(person_id) AS person_count\n  FROM person \n  WHERE year_of_birth &lt; 2000;\n\n\n1 records\n\nperson_count\n\n\n2694\n\n\n\n\nNow that we are going to use JOINs, we will be using aliases and table references a lot.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#join",
    "href": "week2.html#join",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.4 JOIN\n",
    "text": "3.4 JOIN\n\nWe use the JOIN clause when we want to combine information from two tables. Here we are going to combine information from two tables: procedure_occurrence and concept.\nTo set the stage, let’s show two tables, x and y. We want to join them by the keys, which are represented by colored boxes in both of the tables.\nNote that table x has a key (“3”) that isn’t in table y, and that table y has a key (“4”) that isn’t in table x.\n\nWe are going to explore INNER JOIN first. In an INNER JOIN, we match up our primary key for our table on the foreign key for another table. In this case, we only retain rows that have keys that exist in both the x and y tables. We drop all rows that don’t have matches in both tables.\n There are other types of joins when we want to retain information from the x table or the y table, or both.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#inner-join-syntax",
    "href": "week2.html#inner-join-syntax",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.5 INNER JOIN syntax",
    "text": "3.5 INNER JOIN syntax\nHere’s an example where we are joining procedure_occurrence with concept:\n\nSELECT procedure_occurrence.person_id, concept.concept_name \n    FROM procedure_occurrence \n    INNER JOIN concept\n    ON procedure_occurrence.procedure_concept_id = concept.concept_id\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\n\n\n\n343\nSubcutaneous immunotherapy\n\n\n357\nSubcutaneous immunotherapy\n\n\n399\nSubcutaneous immunotherapy\n\n\n406\nSubcutaneous immunotherapy\n\n\n411\nSubcutaneous immunotherapy\n\n\n430\nPlain X-ray of clavicle\n\n\n442\nSubcutaneous immunotherapy\n\n\n453\nCognitive and behavioral therapy\n\n\n469\nCognitive and behavioral therapy\n\n\n488\nSputum examination\n\n\n\n\n\nWhat’s going on here? The magic happens with this clause, which we use to specify the two tables we need to join.\nFROM procedure_occurrence\n  INNER JOIN concept\nThe last thing to note is the ON statement. These are the conditions by which we merge rows. Note we are taking one column in procedure.occurrence, the procedure_concept_id, and matching the rows up with those rows in concept\nON procedure_occurrence.procedure_concept_id = concept.concept_id\n\nSELECT procedure_occurrence.person_id, concept.concept_name \n    FROM procedure_occurrence \n    INNER JOIN concept\n    ON procedure_occurrence.procedure_concept_id = concept.concept_id\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\n\n\n\n343\nSubcutaneous immunotherapy\n\n\n357\nSubcutaneous immunotherapy\n\n\n399\nSubcutaneous immunotherapy\n\n\n406\nSubcutaneous immunotherapy\n\n\n411\nSubcutaneous immunotherapy\n\n\n430\nPlain X-ray of clavicle\n\n\n442\nSubcutaneous immunotherapy\n\n\n453\nCognitive and behavioral therapy\n\n\n469\nCognitive and behavioral therapy\n\n\n488\nSputum examination\n\n\n\n\n\nHere is the same query using aliases. We use po as an alias for procedure_occurrence and c as an alias for concept. You can see it is a little more compact.\n\nSELECT po.person_id, c.concept_name \n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id;",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#left-join",
    "href": "week2.html#left-join",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.6 LEFT JOIN\n",
    "text": "3.6 LEFT JOIN\n\n\n\n\n\n\n\nJargon alert\n\n\n\nThe table to the left of the JOIN clause is called the left table, and the table to the right of the JOIN clause is known as the right table. This will become more important as we explore the different join types.\nFROM procedure_occurrence INNER JOIN concept\n      ^^Left Table                    ^^Right Table\n\n\nWhat if we want to retain all of the rows in the procedure_occurrence table, even if there are no matches in the concept table? We can use a LEFT JOIN to do that.\n\nIf a row exists in the left table, but not the right table, it will be replicated in the joined table, but have rows with NULL columns from the right table.\nI tried to find some examples where LEFT JOINed tables were different than INNER JOINed tables, but couldn’t find one good example in our tables. Here is another example:\n Nevertheless, here is an example of a LEFT JOIN:\n\nSELECT  c.concept_name, po.person_id, c.domain_id\n    FROM concept as c \n    LEFT JOIN procedure_occurrence AS po\n    ON po.procedure_concept_id = c.concept_id\n    WHERE c.domain_id = 'Procedure'\n\n\nDisplaying records 1 - 10\n\nconcept_name\nperson_id\ndomain_id\n\n\n\nSubcutaneous immunotherapy\n343\nProcedure\n\n\nSubcutaneous immunotherapy\n357\nProcedure\n\n\nSubcutaneous immunotherapy\n399\nProcedure\n\n\nSubcutaneous immunotherapy\n406\nProcedure\n\n\nSubcutaneous immunotherapy\n411\nProcedure\n\n\nPlain X-ray of clavicle\n430\nProcedure\n\n\nSubcutaneous immunotherapy\n442\nProcedure\n\n\nCognitive and behavioral therapy\n453\nProcedure\n\n\nCognitive and behavioral therapy\n469\nProcedure\n\n\nSputum examination\n488\nProcedure",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#other-kinds-of-joins",
    "href": "week2.html#other-kinds-of-joins",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.7 Other kinds of JOINs",
    "text": "3.7 Other kinds of JOINs\n\nThe RIGHT JOIN is identical to LEFT JOIN, except that the rows preserved are from the right table.\nThe FULL JOIN retains all rows in both tables, regardless if there is a key match.\n\nANTI JOIN is helpful to find all of the keys that are in the left table, but not the right table",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#multiple-joins-with-multiple-tables",
    "href": "week2.html#multiple-joins-with-multiple-tables",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.8 Multiple JOINs with Multiple Tables",
    "text": "3.8 Multiple JOINs with Multiple Tables\nWe can have multiple joins by thinking them as a sequential operation of one join after another. In the below query we first INNER JOIN person and procedure_occurrence, and then use the output of that JOIN to INNER JOIN with concept:\n\nSELECT p.gender_source_value, c.concept_name, po.procedure_date\n  FROM person AS p\n  INNER JOIN procedure_occurrence AS po\n  ON p.person_id = po.person_id\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  LIMIT 10;\n\n\nDisplaying records 1 - 10\n\ngender_source_value\nconcept_name\nprocedure_date\n\n\n\nF\nSubcutaneous immunotherapy\n1992-02-01\n\n\nF\nSubcutaneous immunotherapy\n1990-11-14\n\n\nM\nSubcutaneous immunotherapy\n1991-09-08\n\n\nM\nSubcutaneous immunotherapy\n1990-02-13\n\n\nM\nSubcutaneous immunotherapy\n1992-01-11\n\n\nF\nPlain X-ray of clavicle\n1938-10-11\n\n\nF\nSubcutaneous immunotherapy\n1992-10-31\n\n\nM\nCognitive and behavioral therapy\n1984-03-20\n\n\nF\nCognitive and behavioral therapy\n1948-04-26\n\n\nM\nSputum examination\n1962-09-21\n\n\n\n\n\nThe way I think of these multi-table joins is to decompose them into two joins:\n\nWe first INNER JOIN person and procedure_occurrence, to produce an output table\nWe take this output table and INNER JOIN it with concept.\n\nNotice that both of these JOINs have separate ON statements. For the first join, we have:\nINNER JOIN procedure_occurrence AS po\n  ON p.person_id = po.person_id\nFor the second JOIN, we have:\nINNER JOIN concept AS c\nON po.procedure_concept_id = c.concept_id\nAnd that gives us the final table, which takes variables from all three tables.\nOne thing to keep in mind is that JOINs are not necessarily commutative; that is, the order of joins can matter. This is because we may drop or preserve rows depending on the JOIN.\nFor combining INNER JOINs, we are looking for the subset of keys that exist in each table, so join order doesn’t matter. But for combining LEFT JOINs and RIGHT JOINS, order can matter.\nIt’s really important to check intermediate output and make sure that you are retaining the rows that you need in the final output. For example, I’d try the first join first and see that it contains the rows that I need before adding the second join.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#using-join-with-where",
    "href": "week2.html#using-join-with-where",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.9 Using JOIN with WHERE\n",
    "text": "3.9 Using JOIN with WHERE\n\nWhere we really start to cook with gas is when we combine JOIN with WHERE. Here, we’re joining procedure_occurrence and concept, with an additional WHERE where we only want those rows that have the concept_name of ’Subcutaneous immunotherapy`:\n\nSELECT po.person_id, c.concept_name \n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    WHERE c.concept_name = 'Subcutaneous immunotherapy';\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\n\n\n\n343\nSubcutaneous immunotherapy\n\n\n357\nSubcutaneous immunotherapy\n\n\n399\nSubcutaneous immunotherapy\n\n\n406\nSubcutaneous immunotherapy\n\n\n411\nSubcutaneous immunotherapy\n\n\n442\nSubcutaneous immunotherapy\n\n\n499\nSubcutaneous immunotherapy\n\n\n533\nSubcutaneous immunotherapy\n\n\n563\nSubcutaneous immunotherapy\n\n\n680\nSubcutaneous immunotherapy\n\n\n\n\n\nHere is a triple join query with an additional filter. You can see why aliases are useful:\n\nSELECT po.person_id, c.concept_name, p.birth_datetime \n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    INNER JOIN person as p\n    ON po.person_id = p.person_id\n    WHERE p.year_of_birth &lt; 1980;\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\nbirth_datetime\n\n\n\n343\nSubcutaneous immunotherapy\n1970-01-31\n\n\n357\nSubcutaneous immunotherapy\n1954-10-13\n\n\n399\nSubcutaneous immunotherapy\n1955-04-03\n\n\n406\nSubcutaneous immunotherapy\n1952-02-19\n\n\n411\nSubcutaneous immunotherapy\n1959-02-21\n\n\n430\nPlain X-ray of clavicle\n1931-06-20\n\n\n442\nSubcutaneous immunotherapy\n1947-08-23\n\n\n453\nCognitive and behavioral therapy\n1970-05-15\n\n\n469\nCognitive and behavioral therapy\n1935-11-30\n\n\n488\nSputum examination\n1954-10-01\n\n\n\n\n\n\n\n\n\n\n\nWHERE vs ON\n\n\n\nYou will see variations of SQL statements that eliminate JOIN and ON entirely, putting everything in WHERE:\n\nSELECT po.person_id, c.concept_name \n    FROM procedure_occurrence as po, concept as c\n    WHERE c.concept_name = 'Subcutaneous immunotherapy'\n    AND po.procedure_concept_id = c.concept_id\n    LIMIT 10;\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\n\n\n\n343\nSubcutaneous immunotherapy\n\n\n357\nSubcutaneous immunotherapy\n\n\n399\nSubcutaneous immunotherapy\n\n\n406\nSubcutaneous immunotherapy\n\n\n411\nSubcutaneous immunotherapy\n\n\n442\nSubcutaneous immunotherapy\n\n\n499\nSubcutaneous immunotherapy\n\n\n533\nSubcutaneous immunotherapy\n\n\n563\nSubcutaneous immunotherapy\n\n\n680\nSubcutaneous immunotherapy\n\n\n\n\n\nI’m not the biggest fan of this, because it is often not clear what is a filtering clause and what is a joining clause, so I prefer to use JOIN/ON with a WHERE.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#boolean-logic-and-versus-or",
    "href": "week2.html#boolean-logic-and-versus-or",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.10 Boolean Logic: AND versus OR\n",
    "text": "3.10 Boolean Logic: AND versus OR\n\nRevisiting WHERE, we can combine conditions with AND or OR.\nAND is always going to be more restrictive than OR, because our rows must meet two conditions.\n\nSELECT COUNT(*)\n  FROM person\n  WHERE year_of_birth &lt; 1980 \n  AND gender_source_value = 'M'\n\n\n1 records\n\ncount_star()\n\n\n1261\n\n\n\n\nOn the other hand OR is more permissing than AND, because our rows must meet only one of the conditions.\n\nSELECT COUNT(*)\n  FROM person\n  WHERE year_of_birth &lt; 1980 \n  OR gender_source_value = 'M'\n\n\n1 records\n\ncount_star()\n\n\n2629\n\n\n\n\nThere is also NOT, where one condition must be true, and the other must be false.\n\nSELECT COUNT(*)\n  FROM person\n  WHERE year_of_birth &lt; 1980 \n  AND NOT gender_source_value = 'M'\n\n\n1 records\n\ncount_star()\n\n\n1308",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#order-by",
    "href": "week2.html#order-by",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.11 ORDER BY\n",
    "text": "3.11 ORDER BY\n\nORDER BY lets us sort tables by one or more columns:\n\nSELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.procedure_date;\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\nprocedure_date\n\n\n\n2088\nBone immobilization\n1911-09-07\n\n\n2088\nRadiography of ankle\n1911-09-07\n\n\n2858\nRadiography of wrist\n1912-03-11\n\n\n2858\nBone immobilization\n1912-03-11\n\n\n4165\nSputum examination\n1912-03-15\n\n\n1658\nBrief general examination\n1912-04-30\n\n\n1658\nMedication Reconciliation\n1912-04-30\n\n\n1658\nReview of systems\n1912-04-30\n\n\n4643\nSuture open wound\n1912-12-27\n\n\n4643\nSputum examination\n1913-05-27\n\n\n\n\n\nWe can ORDER BY multiple columns. Column order is important. Try changing the order of the columns in the query below. How is it different?\n\nSELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.person_id, po.procedure_date;\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\nprocedure_date\n\n\n\n1\nBone immobilization\n1958-03-11\n\n\n1\nRadiography of humerus\n1958-03-11\n\n\n1\nRadiologic examination of knee\n1981-08-10\n\n\n1\nSurgical manipulation of joint of knee\n1981-08-17\n\n\n1\nSuture open wound\n1982-09-11\n\n\n2\nBone immobilization\n1924-01-12\n\n\n2\nRadiography of humerus\n1924-01-12\n\n\n2\nSputum examination\n1931-09-03\n\n\n2\nPlain X-ray of clavicle\n1934-01-19\n\n\n2\nSuture open wound\n1952-07-13",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#try-it-out",
    "href": "week2.html#try-it-out",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.12 Try it OUt",
    "text": "3.12 Try it OUt\nTry ordering by po.patient_id:\n\nSELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence AS po \n    INNER JOIN concept AS c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.procedure_date;\n\n\nDisplaying records 1 - 10\n\nperson_id\nconcept_name\nprocedure_date\n\n\n\n2088\nBone immobilization\n1911-09-07\n\n\n2088\nRadiography of ankle\n1911-09-07\n\n\n2858\nRadiography of wrist\n1912-03-11\n\n\n2858\nBone immobilization\n1912-03-11\n\n\n4165\nSputum examination\n1912-03-15\n\n\n1658\nBrief general examination\n1912-04-30\n\n\n1658\nMedication Reconciliation\n1912-04-30\n\n\n1658\nReview of systems\n1912-04-30\n\n\n4643\nSuture open wound\n1912-12-27\n\n\n4643\nSputum examination\n1913-05-27",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#transactions-and-inserting-data",
    "href": "week2.html#transactions-and-inserting-data",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.13 Transactions and Inserting Data",
    "text": "3.13 Transactions and Inserting Data\nSo far, we’ve only queried data, but not added data to databases.\nAs we’ve stated before, DuckDB is an Analytical database, not a transactional one. That means it prioritizes reading from data tables rather than inserting into them. Transactional databases, on the other hand, can handle multiple inserts from multiple users at once. They are made for concurrent transactions.\nHere is an example of what is called the Data Definition Language for our tables:\nCREATE TABLE @cdmDatabaseSchema.PERSON (\n            person_id integer NOT NULL,\n            gender_concept_id integer NOT NULL,\n            year_of_birth integer NOT NULL,\n            month_of_birth integer NULL,\n            day_of_birth integer NULL,\n            birth_datetime TIMESTAMP NULL,\n            race_concept_id integer NOT NULL,\n            ethnicity_concept_id integer NOT NULL,\n            location_id integer NULL,\n            provider_id integer NULL,\n            care_site_id integer NULL,\n            person_source_value varchar(50) NULL,\n            gender_source_value varchar(50) NULL,\n            gender_source_concept_id integer NULL,\n            race_source_value varchar(50) NULL,\n            race_source_concept_id integer NULL,\n            ethnicity_source_value varchar(50) NULL,\n            ethnicity_source_concept_id integer NULL );\nWhen we add rows into a database, we need to be aware of the constraints of the database. They exist to maintain the integrity of a database.\nWe’ve encountered one constraint: database fields need to be typed. For example, id keys are usually INTEGER. Names are often VARCHAR.\nOne contraint is the requirement for unique keys for each row. We cannot add a new row with a previous key value.\n\nNOT NULL\nUNIQUE\n\nPRIMARY KEY - NOT NULL + UNIQUE\n\n\nFOREIGN KEY - value must exist as a key in another table\n\nCHECK - check the data type and conditions. One example would be our data shouldn’t be before 1900.\n\nDEFAULT - default values.\n\nThe most important ones to know about are PRIMARY KEY and FOREIGN KEY. PRIMARY KEY forces the database to create new rows with an automatically incremented id.\nWhen we create tables in our database, we need to specify which column is a PRIMARY KEY:\nCREATE TABLE person (\n  person_id INTEGER PRIMARY KEY\n)\nFOREIGN KEY involves two or more tables. If a column is declared a FOREIGN KEY, then that key value must exist in a REFERENCE table. Here our two reference tables are person and procedure_occurrence.\nCREATE TABLE procedure_occurrence {\n  procedure_occurrence_id PRIMARY KEY,\n  person_id INTEGER REFERENCES person(person_id)\n  procedure_concept_id INTEGER REFERENCES concept(concept_id)\n}\nThus, we can use constraints to make sure that our database retains its integrity when we add rows to it.\nThere are more constraints we can add to our tables, and the correct use of these constraints will ensure that our data is correct.\nYou can see an example of constraints for our database here: https://github.com/OHDSI/CommonDataModel/blob/v5.4.0/inst/ddl/5.4/postgresql/OMOPCDM_postgresql_5.4_constraints.sql.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#always-close-the-connection",
    "href": "week2.html#always-close-the-connection",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.14 Always close the connection",
    "text": "3.14 Always close the connection\nWhen we’re done, it’s best to close the connection with dbDisconnect().\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week2.html#references",
    "href": "week2.html#references",
    "title": "\n3  Week 2: JOINs, More WHERE, Boolean Logic, ORDER BY\n",
    "section": "\n3.15 References",
    "text": "3.15 References\n\n\nTidyexplain - All JOIN animations come from here.\n\nUnderstanding Joins - another nice visual explanation from R for Data Science.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2: `JOIN`s, More `WHERE`, Boolean Logic, `ORDER BY`</span>"
    ]
  },
  {
    "objectID": "week3.html",
    "href": "week3.html",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "",
    "text": "4.1 Connecting to our database\nLet’s connect to our database.\nlibrary(duckdb)\n\nLoading required package: DBI\n\nlibrary(DBI)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), \n                      \"data/GiBleed_5.3_1.1.duckdb\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#group-by",
    "href": "week3.html#group-by",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.2 GROUP BY\n",
    "text": "4.2 GROUP BY\n\nSay we want to count, calculate totals, or averages for a particular column by a particular grouping variable. We can use a SELECT/GROUP BY pattern to do this.\nThere are some requirements to using SELECT/GROUP BY:\n\nGrouping variable should be categorical (such as c.concept_name)\nGrouping variable must be in SELECT clause (c.concept_name)\n\nCount the number of persons by gender_source_value:\n\nSELECT gender_source_value, COUNT(person_id) AS person_count\n  FROM person\n  GROUP BY gender_source_value\n\n\n2 records\n\ngender_source_value\nperson_count\n\n\n\nF\n1373\n\n\nM\n1321\n\n\n\n\n\nHere, we’re combining SELECT/GROUP_BY with an INNER JOIN:\n\nSELECT c.concept_name AS procedure, COUNT(person_id) AS person_count\n  FROM procedure_occurrence AS po\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  GROUP BY c.concept_name\n  ORDER BY person_count DESC\n\n\nDisplaying records 1 - 10\n\nprocedure\nperson_count\n\n\n\nSubcutaneous immunotherapy\n17520\n\n\nCognitive and behavioral therapy\n2820\n\n\nSuture open wound\n2487\n\n\nBone immobilization\n1789\n\n\nSputum examination\n1659\n\n\nDirect current cardioversion\n1342\n\n\nIntramuscular injection\n908\n\n\nPulmonary rehabilitation\n908\n\n\nAllergy screening test\n704\n\n\nBone density scan\n655\n\n\n\n\n\nWe can group by multiple variables. Here is a triple join where we are counting by both gender_source_value and concept_name:\n\nSELECT c.concept_name AS procedure, p.gender_source_value, COUNT(p.person_id) AS person_count\n  FROM procedure_occurrence AS po\n  INNER JOIN person AS p\n  ON p.person_id = po.person_id\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  GROUP BY c.concept_name, p.gender_source_value\n  ORDER BY person_count DESC\n\n\nDisplaying records 1 - 10\n\nprocedure\ngender_source_value\nperson_count\n\n\n\nSubcutaneous immunotherapy\nF\n9480\n\n\nSubcutaneous immunotherapy\nM\n8040\n\n\nCognitive and behavioral therapy\nM\n1872\n\n\nSuture open wound\nF\n1293\n\n\nSuture open wound\nM\n1194\n\n\nCognitive and behavioral therapy\nF\n948\n\n\nBone immobilization\nF\n933\n\n\nIntramuscular injection\nF\n908\n\n\nBone immobilization\nM\n856\n\n\nSputum examination\nM\n841\n\n\n\n\n\n\n4.2.1 Check on Learning\nCOUNT the number of concept_ids grouped by domain_id in the concept table:\n\nSELECT domain_id, COUNT(------) AS count_domain\n  FROM concept\n  GROUP BY -------\n  ORDER BY count_domain DESC",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#having",
    "href": "week3.html#having",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.3 HAVING\n",
    "text": "4.3 HAVING\n\nWe can filter by these aggregate variables. But we can’t use them in a WHERE clause. There is an additional clause HAVING:\n\nSELECT c.concept_name AS procedure, COUNT(person_id) AS person_count\n  FROM procedure_occurrence AS po\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  GROUP BY c.concept_name\n  HAVING person_count &gt; 500\n  ORDER BY person_count DESC\n\n\nDisplaying records 1 - 10\n\nprocedure\nperson_count\n\n\n\nSubcutaneous immunotherapy\n17520\n\n\nCognitive and behavioral therapy\n2820\n\n\nSuture open wound\n2487\n\n\nBone immobilization\n1789\n\n\nSputum examination\n1659\n\n\nDirect current cardioversion\n1342\n\n\nIntramuscular injection\n908\n\n\nPulmonary rehabilitation\n908\n\n\nAllergy screening test\n704\n\n\nBone density scan\n655\n\n\n\n\n\nWhy can’t we use WHERE? WHERE is actually evaluated before SELECT/GROUP_BY, so it has no idea that the aggregated variables exist. Remember SQL clause priorities?. WHERE is priority 2, and GROUP BY/HAVING are priorities 3 and 4.\nIn general, you need to put WHERE before GROUP BY/HAVING. Your SQL statement will not work if you put WHERE after GROUP BY / HAVING.\nHere is an example of using both WHERE and HAVING:\n\nSELECT domain_id, COUNT(concept_id) AS count_domain\n  FROM concept\n  WHERE domain_id != 'Drug'\n  GROUP BY domain_id\n  HAVING count_domain &gt; 40\n  ORDER BY count_domain DESC\n\n\n3 records\n\ndomain_id\ncount_domain\n\n\n\nCondition\n86\n\n\nMeasurement\n59\n\n\nProcedure\n54\n\n\n\n\n\n\nsql_statement &lt;- \"EXPLAIN SELECT domain_id, COUNT(concept_id) AS count_domain\n  FROM concept\n  WHERE domain_id != 'Drug'\n  GROUP BY domain_id\n  HAVING count_domain &gt; 40\n  ORDER BY count_domain DESC\"\n\nDBI::dbGetQuery(con, sql_statement)\n\nphysical_plan\n┌───────────────────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_decompress_strin│\n│           g(#0)           │\n│             #1            │\n│                           │\n│          ~1 Rows          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│          ORDER_BY         │\n│    ────────────────────   │\n│    count(GiBleed_5.main   │\n│ .concept.concept_id) DESC │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_compress_string_│\n│        hugeint(#0)        │\n│             #1            │\n│                           │\n│          ~1 Rows          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│           FILTER          │\n│    ────────────────────   │\n│    (count_domain &gt; 40)    │\n│                           │\n│          ~1 Rows          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_decompress_strin│\n│           g(#0)           │\n│             #1            │\n│                           │\n│          ~7 Rows          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│       HASH_GROUP_BY       │\n│    ────────────────────   │\n│         Groups: #0        │\n│                           │\n│        Aggregates:        │\n│        count_star()       │\n│                           │\n│          ~7 Rows          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│         domain_id         │\n│                           │\n│          ~88 Rows         │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_compress_string_│\n│        hugeint(#0)        │\n│             #1            │\n│                           │\n│          ~88 Rows         │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         SEQ_SCAN          │\n│    ────────────────────   │\n│       Table: concept      │\n│   Type: Sequential Scan   │\n│                           │\n│        Projections:       │\n│         domain_id         │\n│         concept_id        │\n│                           │\n│          Filters:         │\n│     domain_id!='Drug'     │\n│                           │\n│          ~88 Rows         │\n└───────────────────────────┘\n\n\nHere’s what happens when you put WHERE after GROUP BY/HAVING:\n\nSELECT domain_id, COUNT(concept_id) AS count_domain\n  FROM concept\n  GROUP BY domain_id\n  HAVING count_domain &gt; 40\n  WHERE domain_id != 'Drug'\n  ORDER BY count_domain DESC\n\nHere is WHERE/GROUP BY/HAVING combined with an INNER JOIN:\n\nSELECT c.concept_name AS procedure, COUNT(person_id) AS person_count\n  FROM procedure_occurrence AS po\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  WHERE date_part('YEAR', po.procedure_datetime) &gt; 2000\n  GROUP BY c.concept_name\n  HAVING person_count &gt; 500\n  ORDER BY person_count DESC\n\n\n4 records\n\nprocedure\nperson_count\n\n\n\nDirect current cardioversion\n1031\n\n\nSubcutaneous immunotherapy\n705\n\n\nSuture open wound\n697\n\n\nPulmonary rehabilitation\n611\n\n\n\n\n\nWe can group by year by first extracting it from po.procedure_datetime and using an alias year:\n\nSELECT date_part('YEAR', po.procedure_datetime) AS year, COUNT(po.person_id) AS procedure_count\n  FROM procedure_occurrence AS po\n  INNER JOIN concept AS c\n  ON po.procedure_concept_id = c.concept_id\n  GROUP BY year\n  ORDER BY procedure_count DESC\n\n\nDisplaying records 1 - 10\n\nyear\nprocedure_count\n\n\n\n1992\n4717\n\n\n1990\n4599\n\n\n1991\n4506\n\n\n1993\n2843\n\n\n1997\n725\n\n\n1995\n690\n\n\n1996\n685\n\n\n1994\n614\n\n\n1998\n598\n\n\n1999\n455",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#inlike",
    "href": "week3.html#inlike",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.4 IN/LIKE\n",
    "text": "4.4 IN/LIKE\n\nA couple of twists to WHERE. We can use IN to search on multiple conditions. We put the multiple words in a () separated by commas:\n\nSELECT concept_name, domain_id \n  FROM concept\n  WHERE domain_id IN ('Drug', 'Condition')\n\n\nDisplaying records 1 - 10\n\n\n\n\n\nconcept_name\ndomain_id\n\n\n\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\n\n\npneumococcal polysaccharide vaccine, 23 valent\nDrug\n\n\nAlendronate\nDrug\n\n\nAmpicillin 100 MG/ML Injectable Solution\nDrug\n\n\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\n\n\nrotavirus, live, monovalent vaccine\nDrug\n\n\nMidazolam\nDrug\n\n\nDiclofenac Sodium 75 MG Delayed Release Oral Tablet\nDrug\n\n\nDiclofenac Sodium 75 MG Delayed Release Oral Tablet\nDrug\n\n\ntetanus and diphtheria toxoids, adsorbed, preservative free, for adult use\nDrug\n\n\n\n\n\nWe can use NOT with IN to exclude a list of conditions:\n\nSELECT concept_name, domain_id \n  FROM concept\n  WHERE domain_id NOT IN ('Drug', 'Condition')\n\n\nDisplaying records 1 - 10\n\nconcept_name\ndomain_id\n\n\n\nCoronary artery bypass graft\nProcedure\n\n\nIntramuscular injection\nProcedure\n\n\nProtein serum/plasma\nMeasurement\n\n\nSurgical manipulation of shoulder joint\nProcedure\n\n\nNeonatal screening\nProcedure\n\n\nHoney bee IgE Ab [Units/volume] in Serum\nMeasurement\n\n\nErythrocyte distribution width [Ratio]\nMeasurement\n\n\nRemoval of subcutaneous contraceptive\nProcedure\n\n\nCladosporium herbarum IgE Ab [Units/volume] in Serum\nMeasurement\n\n\nCommon Ragweed IgE Ab [Units/volume] in Serum\nMeasurement\n\n\n\n\n\nOne note. It is usually faster to make a temporary table with your values and join on that temporary table. We’ll talk more about this below.\nLIKE is one way to do wild card searches.\n\nSELECT concept_name, domain_id \n  FROM concept\n  WHERE domain_id LIKE 'Dru%'\n\n\nDisplaying records 1 - 10\n\n\n\n\n\nconcept_name\ndomain_id\n\n\n\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\n\n\npneumococcal polysaccharide vaccine, 23 valent\nDrug\n\n\nAlendronate\nDrug\n\n\nAmpicillin 100 MG/ML Injectable Solution\nDrug\n\n\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\n\n\nrotavirus, live, monovalent vaccine\nDrug\n\n\nMidazolam\nDrug\n\n\nDiclofenac Sodium 75 MG Delayed Release Oral Tablet\nDrug\n\n\nDiclofenac Sodium 75 MG Delayed Release Oral Tablet\nDrug\n\n\ntetanus and diphtheria toxoids, adsorbed, preservative free, for adult use\nDrug",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#creating-temporary-tables",
    "href": "week3.html#creating-temporary-tables",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.5 Creating Temporary Tables",
    "text": "4.5 Creating Temporary Tables\nTemporary tables can be very useful when you are trying to merge on a list of concepts, or for storing intermediate results.\nTemporary tables only last for the session - they disappear after you disconnect, so don’t use them for permanent storage.\nHere is the csv (comma separated value) file that we’re going to load in:\n\nread_csv(\"data/temp_cost.csv\")\n\nRows: 51 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): concept_name\ndbl (2): procedure_concept_id, cost\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 51 × 3\n   concept_name                          procedure_concept_id  cost\n   &lt;chr&gt;                                                &lt;dbl&gt; &lt;dbl&gt;\n 1 Cognitive and behavioral therapy                   4043071  3300\n 2 Nasal sinus endoscopy                              4010253  3000\n 3 Intubation                                         4202832  4000\n 4 Removal of subcutaneous contraceptive              4199276  1800\n 5 Radiography of humerus                             4047491  2300\n 6 Radiologic examination of knee                     4252419  4100\n 7 Lung volume reduction surgery                      4323902   730\n 8 Sputum examination                                 4151422  4000\n 9 Percutaneous coronary intervention                 4216130  1800\n10 Injection of epinephrine                           4197460  2600\n# ℹ 41 more rows\n\n\nWe use CREATE TEMP TABLE to create a temp table. We will need to specify the data types of the columns before we can add data to it. We are using CREATE OR REPLACE in the below chunk to prevent errors when we run it, just in case we have run it before.\nThen we can use COPY from DuckDB to load it in:\n\nCREATE OR REPLACE TEMP TABLE cost(\n  concept_name VARCHAR,\n  procedure_concept_id INT,\n  cost INT\n);\nCOPY cost FROM 'data/temp_cost.csv'\n\nDuckDB also is smart enough to infer the column types and names from the data:\n\nCREATE OR REPLACE TEMP TABLE cost AS\n  SELECT * FROM read_csv('data/temp_cost.csv')\n\nNow our table exists in our database, and we can work with it.\n\nSELECT * FROM cost\n\n\nDisplaying records 1 - 10\n\nconcept_name\nprocedure_concept_id\ncost\n\n\n\nCognitive and behavioral therapy\n4043071\n3300\n\n\nNasal sinus endoscopy\n4010253\n3000\n\n\nIntubation\n4202832\n4000\n\n\nRemoval of subcutaneous contraceptive\n4199276\n1800\n\n\nRadiography of humerus\n4047491\n2300\n\n\nRadiologic examination of knee\n4252419\n4100\n\n\nLung volume reduction surgery\n4323902\n730\n\n\nSputum examination\n4151422\n4000\n\n\nPercutaneous coronary intervention\n4216130\n1800\n\n\nInjection of epinephrine\n4197460\n2600\n\n\n\n\n\n\nDESCRIBE cost\n\n\n3 records\n\ncolumn_name\ncolumn_type\nnull\nkey\ndefault\nextra\n\n\n\nconcept_name\nVARCHAR\nYES\nNA\nNA\nNA\n\n\nprocedure_concept_id\nBIGINT\nYES\nNA\nNA\nNA\n\n\ncost\nBIGINT\nYES\nNA\nNA\nNA\n\n\n\n\n\nNow we can merge our temporary cost table with procedure_occurrence and calculate the sum cost per year:\n\nSELECT date_part('YEAR', po.procedure_datetime) AS year, SUM(cost) AS sum_cost_month\n  FROM procedure_occurrence AS po\n  INNER JOIN cost AS c\n  ON po.procedure_concept_id = c.procedure_concept_id\n  GROUP BY year\n  ORDER BY year DESC\n\n\nDisplaying records 1 - 10\n\nyear\nsum_cost_month\n\n\n\n2019\n619380\n\n\n2018\n1271370\n\n\n2017\n1201430\n\n\n2016\n1122680\n\n\n2015\n1079390\n\n\n2014\n1103730\n\n\n2013\n1084430\n\n\n2012\n1118890\n\n\n2011\n1041720\n\n\n2010\n1015700\n\n\n\n\n\nWe’ll talk much more about subqueries and Views next time, which are another options to split queries up.\n\n4.5.1 Check on Learning\nModify the query below to calculate average cost per month using AVG(cost) named as average_monthly_cost:\n\nSELECT date_part('YEAR', po.procedure_datetime) AS year, SUM(cost)\n  FROM procedure_occurrence AS po\n  INNER JOIN cost AS c\n  ON po.procedure_concept_id = c.procedure_concept_id\n  GROUP BY year\n  ORDER BY year DESC\n\n\nDisplaying records 1 - 10\n\nyear\nsum(“cost”)\n\n\n\n2019\n619380\n\n\n2018\n1271370\n\n\n2017\n1201430\n\n\n2016\n1122680\n\n\n2015\n1079390\n\n\n2014\n1103730\n\n\n2013\n1084430\n\n\n2012\n1118890\n\n\n2011\n1041720\n\n\n2010\n1015700",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#data-integrity",
    "href": "week3.html#data-integrity",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.6 Data Integrity",
    "text": "4.6 Data Integrity\nWe talked a little bit last week about database constraints, such as FOREIGN KEY constraints, where we can’t add a row that refers to a foreign key if that foreign key doesn’t exist.\nThese constraints exist to ensure the data integrity of a database. For example, we don’t want to have rows in procedure_occurrence that have procedure_concept_id that don’t exist in the concept table.\nAnother way to keep data integrity is to have all operations be ACID compliant transactions. That is, all operations (inserting and removing rows) needs to be done in full before the next set of transactions (which could come from another user) are done to the database.\nACID is short for:\n\n\nAtomicity - the operation must be all or none\n\nConsistency - the operation must be done the same way\n\nIsolation - the operation is not dependent on other operations, and is done in series, not parallel.\n\nDurability - the operation must be robust to disruptions (like power outages). If a database is interrupted in an update, there must be a rollback mechanism to get the previous version of the data.\n\nFinally, the design of the tables and what information they contain, and how they relate to each other is also important to data integrity. The process of deciding which columns belong to which tables is called normalization.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#database-design",
    "href": "week3.html#database-design",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.7 Database Design",
    "text": "4.7 Database Design\nDatabase design can be difficult because:\n\nYou need to understand the requirements of the data and how it is collected\n\n\nFor example, when is procedure information collected?\nDo patients have multiple procedures? (Cardinality)\n\n\nYou need to group like data with like (normalization)\n\n\nData that is dependent on a primary key should stay together\nFor example, person should contain information of a patient such as demographics, but not individual procedure_concept_ids.\n\n\nYou need to have an automated process to add data to the database (Extract Transfer Load, or ETL).\nSearch processes must be optimized for common operations (indexing)\n\nOf this, steps 1 and 2 are the most difficult and take the most time. They require the designer to interview users of the data and those who collect the data to reflect the business processes. These two steps are called the Data Modeling steps.\nThese processes are essential if you are designing a transactional database that is collecting data from multiple sources (such as clinicians at time of care) and is updated multiple times a second. For example, bank databases have a rigorous design.\nIf you want to read more about the data model we’re using, I’ve written up a short bit here: OMOP Data Model.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#database-administration",
    "href": "week3.html#database-administration",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.8 Database Administration",
    "text": "4.8 Database Administration\nMaintaining a database is also known as database administration. Database Admins are responsible for the following:\n\nMaking sure that the data maintains its integrity\nEnsuring that common queries are optimized for fast loading\nGeneral upkeep and optimization. Oftentimes, if multiple people are accessing the data at once, the data may be distributed among multiple machines (load balancing).\nSecurity. We don’t want the wrong people accessing the data.\n\nBeing a good admin does not start from scratch. You can’t be a top-tier admin straight out of school. There are a lot of things DB admins learn, but a lot of the optimization happens from experience with managing the data.\nRespect your DB Admin and know that they know a lot about how to optimize your queries.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week3.html#always-close-the-connection",
    "href": "week3.html#always-close-the-connection",
    "title": "\n4  Week 3: GROUP BY/HAVING\n",
    "section": "\n4.9 Always close the connection",
    "text": "4.9 Always close the connection\nWhen we’re done, it’s best to close the connection with dbDisconnect().\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3: `GROUP BY`/`HAVING`</span>"
    ]
  },
  {
    "objectID": "week4.html",
    "href": "week4.html",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "",
    "text": "5.1 Connecting to our database\nIn this lecture, we will explore subqueries and views in SQL. These concepts help us break complicated queries into smaller, more manageable parts, improving our ability to read and maintain our code.\nAs always, to access the data, we create our database connection to our data.\nlibrary(duckdb)\nlibrary(DBI)\n\ncon &lt;- DBI::dbConnect(\n  duckdb::duckdb(), \n  \"data/GiBleed_5.3_1.1.duckdb\"\n)\nWith our data loaded and ready to go, let’s get started!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#subqueries",
    "href": "week4.html#subqueries",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.2 Subqueries",
    "text": "5.2 Subqueries\nA subquery is a query nested inside another query. Subqueries let us process smaller computations inside larger outer queries.\n\n5.2.1 Using a Subquery in the SELECT Clause\nThe following is a great example from The Data School, offering a visualization of how a subquery works. In this case, we use a subquery to calculate the total number of friends across all individuals, subdivided by state. Here, we are making use of the subquery within our SELECT clause. Let’s dive a little deeper into this type of example using our own data.\n\n\n5.2.1.1 A brief tangent: using DATEDIFF to compare dates\nThe DATEDIFF function in SQL can be used to calculate differences between days. DATEDIFF takes three parameters: the unit of time, a first date, and a second date. For instance, calling:\nSELECT DATEDIFF('month', DATE '2020-01-01', DATE '2024-03-07')\ncalculates the number of months between January 1st, 2020, and March 7th, 2024. All three parameters are required. You can refer to the documentation for DATEDIFF here to see other options for time intervals.\n\n\n\n\n\n\nNote\n\n\n\nDates in SQL typically follow the ISO 8601 format of ‘YYYY-MM-DD’. Other date formats may work depending on the database system being used, though there is a chance for misinterpretation.\nNote that in our example, we explicitly cast our two dates as DATE variables - while this is not necessary depending on the database system, it enhances readability and interpretability of the code for both other users as well as the database system.\n\n\n\nWhat do you think happens if we swap the order of dates in the DATEDIFF command?\n\n5.2.2 Example: Using a Subquery in the SELECT Clause\nLet’s use a subquery to dynamically calculate the age of each individual (as of March 7th, 2024) in our database while collecting other patient demographic data. To handle this, we’ll make use of the person table in our dataframe and the birth_datetime column.\n\nSELECT \n  person_id, \n  birth_datetime,\n  gender_source_value, \n  race_source_value, \n  ethnicity_source_value,\n  (SELECT \n    DATE_DIFF('year', birth_datetime, DATE '2024-03-07')\n  ) AS age\nFROM \n  person;\n\nAs we can see in the above example, we’ve performed the computation of calculating patient age in a subquery:\nSELECT \n    DATE_DIFF('year', birth_datetime, DATE '2024-03-07')\nThis subquery is integrated into the larger query of collecting patient data.\n\n5.2.2.1 Check on learning\nFill in the blank in the query below to dynamically calculate the number of days between the condition start date and condition end date for all conditions from the condition_occurrence table\n\nSELECT \n  person_id,\n  visit_occurrence_id,\n  condition_occurrence_id,\n  condition_concept_id, \n  condition_start_date,\n  condition_end_date,\n  (SELECT \n    DATE_DIFF(_____, _____, _____)\n  ) AS condition_time_span\nFROM \n  condition_occurrence;\n\n\n5.2.3 Filtering with a Subquery\nWe’ve now worked through a couple of examples where we use subqueries to create new variables within our SELECT clause. Another type of query we can tackle is the filtration of data based on conditions calculated in a subquery.\nHere’s another great example from The Data School, where we apply a subquery in the filtration component of our larger query to find individuals on Facebook who have the same number of Facebook connections as anyone else on LinkedIn.\n\n\n5.2.3.1 A brief review: the IN clause\nThe IN clause in SQL is used to filter records where a column matches any value in a specified list or subquery result. It is a shorthand for multiple OR conditions and is commonly used for readability and efficiency.\nFor instance, the basic syntax of:\nSELECT column_name\nFROM table_name\nWHERE column_name IN (value1, value2, value3);\nis equivalent to:\nSELECT column_name\nFROM table_name\nWHERE column_name = value1 \n   OR column_name = value2 \n   OR column_name = value3;\nNow back to using a subquery for filtering!\n\n5.2.4 Example: Filtering with a Subquery\nFor our own database, let’s collect patient demographic data for all patients who had some kind of procedure performed after December 31st, 2018. We’ll make use of the person and procedure_occurrence tables for this query.\nWe can start by writing the computation for our subquery - collection patient IDs for individuals who had a procedure after December 31st, 2018.\n\nSELECT \n  person_id \nFROM \n  procedure_occurrence\nWHERE \n  procedure_datetime &gt;= DATE '2019-01-01';\n\nNow, we can insert this query into the WHERE clause of our larger query that collects patient demographic information!\n\nSELECT \n  person_id, \n  birth_datetime, \n  gender_source_value, \n  race_source_value, \n  ethnicity_source_value\nFROM \n  person\nWHERE \n  person_id IN (\n    SELECT \n      person_id \n    FROM \n      procedure_occurrence\n    WHERE \n      procedure_datetime &gt;= DATE '2019-01-01'\n  );\n\n\n5.2.4.1 Check on learning\nWrite out a query to collection patient IDs for individuals who had a condition start date after December 31st, 2018. This query will become the subquery in our larger computation.\n\nSELECT \n  person_id \nFROM \n  condition_occurrence\nWHERE \n  condition_start_date &gt;= ______\n\nNow, fill in the blank in the following SQL query with the subquery that you just developed to collect patient demographic data for any patient in the condition_occurrence table who had a condition start date on or after January 1st, 2019.\n\nSELECT \n  person_id, \n  birth_datetime, \n  gender_source_value, \n  race_source_value, \n  ethnicity_source_value\nFROM \n  person\nWHERE \n  person_id IN (_________);\n\n\n5.2.5 When to use subqueries\nSubqueries are powerful because they allow you to break down complex queries into smaller, more manageable parts. You should use subqueries when:\n\nYou need to use a computed value in a query: See our previous examples!\nYou want to avoid duplicating code: Instead of repeating a calculation, you can use a subquery to define it a single time and reuse it (i.e. age).\nYou want to avoid performing unnecessary JOIN’s: Subqueries let you filter results row-by-row based on information from another table without requiring a JOIN.\nYou need to improve your code’s readability: Subqueries help make queries more modular and easier to debug. Conceptually, it can be easier to create a multi-step query and check intermediate phases than do perform a bunch of JOIN’s.\n\n\nCan you think of any examples where it might be better to use a JOIN over a subquery?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#views",
    "href": "week4.html#views",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.3 Views",
    "text": "5.3 Views\nA view is a stored SQL query that acts as a virtual table. Views improve code reuse and readability. The following image, taken from SQLShack, depicts how a complicated query can be turned into a customized view that can be used in downstream data processing.\n\n\n5.3.1 When to use views\nSimilar to subqueries, views allow us to organize our data into more modular, accessible, and easy-to-read components. You should use views when:\n\nYou want to simplify complex queries and improve code maintainability: Instead of frequently reusing a complex query, you can store the data generated from the query into a view and access it readily.\nYou want to enhance security and restrict data access to others without authorization: Making your own view can limit access to sensitive columns while still allowing other users to query the necessary data\nYou want to promote data consistency: Performing a calculation in a view ensures that everyone uses the same calculation to grab consistent data (e.g. calculating age of patients)\n\n\n\n\n\n\n\nNote\n\n\n\nA view itself does not actually store data like a physical table does. Instead, a view is a saved SQL query that gets executed each time you query the view.\n\n\n\n5.3.2 A brief tangent: indexing\nIndexing is a technique used to speed up data retrieval from a database table. An index improves the efficiency of queries by allowing the database to locate rows faster without having to scan the entire table. This is similar to how a table of contents in a book helps you quickly find chapters instead of reading every page.\nHowever, views are not indexed: Since views are virtual tables, they do not store data or have their own indexes. Instead, they rely on the indexes that come from the underlying tables. Because views do not have indexes, querying a view can be slower than querying a physical table. Indeed, since the database recomputes the view’s query each time, more complex views can lead to performance issues.\n\n5.3.3 Example: Creating a View\nWith our own data, let’s create a view from the concept table that focuses on the drugs in our dataset.\n\nCREATE VIEW drugs AS\nSELECT * FROM concept\nWHERE domain_id == 'Drug';\n\nNow, we can use this view just like a table:\n\nSELECT * \nFROM drugs\nLIMIT 5;\n\n\n5 records\n\n\n\n\n\n\n\n\n\n\n\n\n\nconcept_id\nconcept_name\ndomain_id\nvocabulary_id\nconcept_class_id\nstandard_concept\nconcept_code\nvalid_start_date\nvalid_end_date\ninvalid_reason\n\n\n\n1118088\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\nRxNorm\nBranded Drug\nS\n213469\n1970-01-01\n2099-12-31\nNA\n\n\n40213201\npneumococcal polysaccharide vaccine, 23 valent\nDrug\nCVX\nCVX\nS\n33\n2008-12-01\n2099-12-31\nNA\n\n\n1557272\nAlendronate\nDrug\nRxNorm\nIngredient\nS\n46041\n1970-01-01\n2099-12-31\nNA\n\n\n19129655\nAmpicillin 100 MG/ML Injectable Solution\nDrug\nRxNorm\nClinical Drug\nS\n789980\n2008-03-30\n2099-12-31\nNA\n\n\n44923712\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\nNDC\n11-digit NDC\nNA\n00025152531\n2000-01-01\n2099-12-31\nNA\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf a view already exists in your database, then trying to create a new view with the same name will generate an error! To delete a view from memory, using the DROP VIEW command. E.g.:\nDROP VIEW IF EXISTS drugs;\n\n\n\n5.3.3.1 Check on learning\nFill in the blank in the query below to create a view that stores only measurements from the concept table\n\nCREATE VIEW measurements AS\nSELECT * FROM concept\nWHERE domain_id == ________;\n\n\nSELECT *\nFROM measurements\nLIMIT 5;",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#query-optimization",
    "href": "week4.html#query-optimization",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.4 Query Optimization",
    "text": "5.4 Query Optimization\nWhile writing efficient SQL queries is important, database performance optimization is a complex topic that is mostly beyond the scope of “Intro to SQL”. However, here are some key takeaways to keep in mind:\n\nDo not manually create indexes: Indexing can significantly improve query performance, but in most cases, it is the responsibility of the Database Administrator (DBA) to manage indexes appropriately. If you believe an index is needed, consult with your DBA.\nWhen in doubt, talk to your database administrator: Especially when your database is transactional, you should not be the one doing these modifications! DBAs have the expertise to optimize database performance, manage indexing, and ensure efficient query execution. Trust your DBA!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#summary",
    "href": "week4.html#summary",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.5 Summary",
    "text": "5.5 Summary\n\nSubqueries allow us to use the result of one query inside another\nViews provide a way to store and reuse complex queries as virtual tables\nUsing subqueries and views can make SQL queries more modular and maintanable.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#always-close-the-connection",
    "href": "week4.html#always-close-the-connection",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.6 Always close the connection",
    "text": "5.6 Always close the connection\nWhen we’re done, always close the connection with dbDisconnect().\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "week4.html#references",
    "href": "week4.html#references",
    "title": "\n5  Week 4: Subqueries and Views\n",
    "section": "\n5.7 References",
    "text": "5.7 References\n\n\nThe Data School - all SUBQUERY animations come from here\n\nSQL Shack - the image depicting the creation of a VIEW comes from here\n\nW3 Schools - a reference for parameter options for DATEDIFF",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 4: Subqueries and Views</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html",
    "href": "miscellaneous.html",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "",
    "text": "6.1 How to Store Passwords\nThis section is for small articles or to answer questions in class.\nA warning: do not store passwords in your code. It is a major security risk.\nThe key to avoiding this is to store the password where your machine can access it, but is not part of your code base. (If you are more advanced, you can store the password in your project directory, but make sure it is in your .gitignore).\nThere are multiple ways to store passwords securely:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#how-to-store-passwords",
    "href": "miscellaneous.html#how-to-store-passwords",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "",
    "text": "Store them as an Environment Variable on your machine\nUse a global .Renviron file to store it outside of your code: https://rstats.wtf/r-startup.html#renviron\nStore them in a secure password manager / keyring (see below).\n\n\n6.1.1 What are environment variables?\nThese are variables that can be seen by all applications, including R/RStudio. They are not stored within code, but as variables in memory. One of the ones you might have had to struggle wiht is JAVA_HOME, whih is where you set a Java installation.\nWe can set environment variables directly, or we can specify them in a file called .Renviron that lives in our home directory.\nWe will use them as a more secure way to store our passwords. We choose the user scope so that it is saved in our home directory, not the project directory. This way, we can protect our password from prying eyes and bots.\n\nusethis::edit_r_environ(scope=\"user\")\n\n☐ Edit '/Users/tladera2/.Renviron'.\n\n\n☐ Restart R for changes to take effect.\n\n\nAdd the following to your .Renviron file:\nCLASS_DB_PASSWORD=\"IntroSQL\"\nYou may have to reopen the project for it to be loaded in your environment variables. We can now load the password using Sys.getenv().\n\nSys.getenv(\"CLASS_DB_PASSWORD\")\n\n[1] \"IntroSQL\"\n\n\nYou can also set the environment variable using Windows Control Panel or PowerShell: https://phoenixnap.com/kb/windows-set-environment-variable - the easiest way to do it is probably the control panel method.\nThere will probably be some sort of authentication process involved in connecting to your databases at Fred Hutch. I’ll add more info when I know more.\nThere is much more about storing passwords and other secrets such as API keys here: https://cran.r-project.org/web/packages/httr/vignettes/secrets.html.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#databases-versus-data-warehouses",
    "href": "miscellaneous.html#databases-versus-data-warehouses",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.2 Databases versus Data Warehouses",
    "text": "6.2 Databases versus Data Warehouses\n\n\n\n\n\ngraph TD\n  A[(Database)] --ETL--&gt; D\n  B[(Database)] --ETL--&gt; D\n  C[(Database)] --ETL--&gt; D\n  D[(Data Warehouse)] \n\n\n\n\n\n\n\n\n\nDatabases: made for data collection, or transactional processing - these systems are made to be updated by multiple sources at once. For example, a collection form that feeds into a database can be submitted by multiple people at once. If you need the latest records, you want to pull from the database.\n\nData Warehouse: Aggregated data from many databases, made for data analysis, or analytical processing. They are usually updated on a nightly basis, taking summary data from each database.\n\nWe will be mostly doing analytical querying, as if our data is stored in a data warehouse.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#whats-the-deal-with-the-semicolon",
    "href": "miscellaneous.html#whats-the-deal-with-the-semicolon",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.3 What’s the deal with the ; (semicolon)?",
    "text": "6.3 What’s the deal with the ; (semicolon)?\nWe use the ; to specify the end of a SQL statement. It is mostly important if you write SQL statements in multiple parts, which we will not do in class.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#keep-in-mind-beware-the-smart-quotes",
    "href": "miscellaneous.html#keep-in-mind-beware-the-smart-quotes",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.4 Keep in Mind: Beware the Smart Quotes",
    "text": "6.4 Keep in Mind: Beware the Smart Quotes\nBeware cutting and pasting code from Microsoft Word\nMicrosoft products such as Word, will transform double quotes \" into what are called smart quotes: “”. This is bad for us, because it breaks our code.\n\"This is the Original String\"\nwill transform into:\n“This is the Original String”\nIt is very hard to see the difference between these, but if you cut and paste the bottom one (from a word document), your code will not run. That’s because the smart quotes aren’t double quotes, which you need to specify a string.\nJust be aware that you might have to fix these quotes if you’re cutting / pasting from a Microsoft product (although google is also guilty of this).\nOftentimes, you can disable this in Word/Google Docs, or be prepared to replace the smart quotes with double quotes. :::",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#dumping-a-query-straight-into-memory",
    "href": "miscellaneous.html#dumping-a-query-straight-into-memory",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.5 Dumping a Query Straight into memory",
    "text": "6.5 Dumping a Query Straight into memory\n\nlibrary(duckdb)\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), \n                      \"data/GiBleed_5.3_1.1.duckdb\")\n\nWe can add a line to our SQL code cell to save the output of our SQL query\n```{sql}\n#| connection: \"con\"\n#| output.var: person\nSELECT * FROM person\n  LIMIT 10;\n```\nIf we run this, we will save the output into the object called person:\n\nSELECT * FROM person\n  LIMIT 10;\n\nWe can work with this as a normal R object now:\n\nperson\n\n   person_id gender_concept_id year_of_birth month_of_birth day_of_birth\n1          6              8532          1963             12           31\n2        123              8507          1950              4           12\n3        129              8507          1974             10            7\n4         16              8532          1971             10           13\n5         65              8532          1967              3           31\n6         74              8532          1972              1            5\n7         42              8532          1909             11            2\n8        187              8507          1945              7           23\n9         18              8532          1965             11           17\n10       111              8532          1975              5            2\n   birth_datetime race_concept_id ethnicity_concept_id location_id provider_id\n1      1963-12-31            8516                    0          NA          NA\n2      1950-04-12            8527                    0          NA          NA\n3      1974-10-07            8527                    0          NA          NA\n4      1971-10-13            8527                    0          NA          NA\n5      1967-03-31            8516                    0          NA          NA\n6      1972-01-05            8527                    0          NA          NA\n7      1909-11-02            8527                    0          NA          NA\n8      1945-07-23            8527                    0          NA          NA\n9      1965-11-17            8527                    0          NA          NA\n10     1975-05-02            8527                    0          NA          NA\n   care_site_id                  person_source_value gender_source_value\n1            NA 001f4a87-70d0-435c-a4b9-1425f6928d33                   F\n2            NA 052d9254-80e8-428f-b8b6-69518b0ef3f3                   M\n3            NA 054d32d5-904f-4df4-846b-8c08d165b4e9                   M\n4            NA 00444703-f2c9-45c9-a247-f6317a43a929                   F\n5            NA 02a3dad9-f9d5-42fb-8074-c16d45b4f5c8                   F\n6            NA 02fbf1be-29b7-4da8-8bbd-14c7433f843f                   F\n7            NA 0177d2e0-98f5-4f3d-bcfd-497b7a07b3f8                   F\n8            NA 07a1e14d-73ed-4d3a-9a39-d729745773fa                   M\n9            NA 0084b0fe-e30f-4930-b6d1-5e1eff4b7dea                   F\n10           NA 0478d6b3-bdb3-4574-9b93-cf448d725b84                   F\n   gender_source_concept_id race_source_value race_source_concept_id\n1                         0             black                      0\n2                         0             white                      0\n3                         0             white                      0\n4                         0             white                      0\n5                         0             black                      0\n6                         0             white                      0\n7                         0             white                      0\n8                         0             white                      0\n9                         0             white                      0\n10                        0             white                      0\n   ethnicity_source_value ethnicity_source_concept_id\n1             west_indian                           0\n2                 italian                           0\n3                  polish                           0\n4                american                           0\n5               dominican                           0\n6                 english                           0\n7                   irish                           0\n8                   irish                           0\n9                 english                           0\n10                english                           0",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#query-plans",
    "href": "miscellaneous.html#query-plans",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.6 Query Plans",
    "text": "6.6 Query Plans\nAll database systems will translate your SQL query into a concrete query plan: this shows step by step, how the engine will execute your query. With DuckDB, we can use EXPLAIN.\nNote that the output of EXPLAIN is not a table, which is why I’m using an R chunk to execute the SQL.\n\nstatement &lt;-   \"EXPLAIN SELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.procedure_date;\"\n\ndbGetQuery(con, statement)\n\nphysical_plan\n┌───────────────────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_decompress_integ│\n│     ral_integer(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│        ~38448 Rows        │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│          ORDER_BY         │\n│    ────────────────────   │\n│   po.procedure_date ASC   │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_compress_integra│\n│     l_usmallint(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│        ~38448 Rows        │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│         person_id         │\n│        concept_name       │\n│       procedure_date      │\n│                           │\n│        ~38448 Rows        │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         HASH_JOIN         │\n│    ────────────────────   │\n│      Join Type: INNER     │\n│                           │\n│        Conditions:        ├──────────────┐\n│   procedure_concept_id =  │              │\n│         concept_id        │              │\n│                           │              │\n│        ~38448 Rows        │              │\n└─────────────┬─────────────┘              │\n┌─────────────┴─────────────┐┌─────────────┴─────────────┐\n│         SEQ_SCAN          ││         SEQ_SCAN          │\n│    ────────────────────   ││    ────────────────────   │\n│           Table:          ││       Table: concept      │\n│    procedure_occurrence   ││   Type: Sequential Scan   │\n│                           ││                           │\n│   Type: Sequential Scan   ││        Projections:       │\n│                           ││         concept_id        │\n│        Projections:       ││        concept_name       │\n│    procedure_concept_id   ││                           │\n│         person_id         ││          Filters:         │\n│       procedure_date      ││  concept_id&gt;=4010253 AND  │\n│                           ││    concept_id&lt;=44805732   │\n│                           ││                           │\n│        ~37409 Rows        ││         ~444 Rows         │\n└───────────────────────────┘└───────────────────────────┘\n\n\nUsing EXPLAIN ANALYZE will not only show the query plan, but also how long it takes to execute each step.\n\nstatement &lt;-   \"EXPLAIN ANALYZE SELECT po.person_id, c.concept_name, po.procedure_date\n    FROM procedure_occurrence as po \n    INNER JOIN concept as c\n    ON po.procedure_concept_id = c.concept_id\n    ORDER BY po.procedure_date;\"\n\ndbGetQuery(con, statement)\n\nanalyzed_plan\n┌─────────────────────────────────────┐\n│┌───────────────────────────────────┐│\n││    Query Profiling Information    ││\n│└───────────────────────────────────┘│\n└─────────────────────────────────────┘\nEXPLAIN ANALYZE SELECT po.person_id, c.concept_name, po.procedure_date     FROM procedure_occurrence as po      INNER JOIN concept as c     ON po.procedure_concept_id = c.concept_id     ORDER BY po.procedure_date;\n┌────────────────────────────────────────────────┐\n│┌──────────────────────────────────────────────┐│\n││              Total Time: 0.0044s             ││\n│└──────────────────────────────────────────────┘│\n└────────────────────────────────────────────────┘\n┌───────────────────────────┐\n│           QUERY           │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│      EXPLAIN_ANALYZE      │\n│    ────────────────────   │\n│           0 Rows          │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_decompress_integ│\n│     ral_integer(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│         37409 Rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│          ORDER_BY         │\n│    ────────────────────   │\n│   po.procedure_date ASC   │\n│                           │\n│         37409 Rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│__internal_compress_integra│\n│     l_usmallint(#0, 1)    │\n│             #1            │\n│             #2            │\n│                           │\n│         37409 Rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│         person_id         │\n│        concept_name       │\n│       procedure_date      │\n│                           │\n│         37409 Rows        │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         HASH_JOIN         │\n│    ────────────────────   │\n│      Join Type: INNER     │\n│                           │\n│        Conditions:        │\n│   procedure_concept_id =  ├──────────────┐\n│         concept_id        │              │\n│                           │              │\n│         37409 Rows        │              │\n│          (0.00s)          │              │\n└─────────────┬─────────────┘              │\n┌─────────────┴─────────────┐┌─────────────┴─────────────┐\n│         TABLE_SCAN        ││         TABLE_SCAN        │\n│    ────────────────────   ││    ────────────────────   │\n│           Table:          ││       Table: concept      │\n│    procedure_occurrence   ││   Type: Sequential Scan   │\n│                           ││                           │\n│   Type: Sequential Scan   ││        Projections:       │\n│                           ││         concept_id        │\n│        Projections:       ││        concept_name       │\n│    procedure_concept_id   ││                           │\n│         person_id         ││          Filters:         │\n│       procedure_date      ││  concept_id&gt;=4010253 AND  │\n│                           ││    concept_id&lt;=44805732   │\n│                           ││                           │\n│         37409 Rows        ││          235 Rows         │\n│          (0.00s)          ││          (0.00s)          │\n└───────────────────────────┘└───────────────────────────┘",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#apache-iceberg",
    "href": "miscellaneous.html#apache-iceberg",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.7 Apache Iceberg",
    "text": "6.7 Apache Iceberg\nOne transactional database format that is starting to be very important is Apache Iceberg.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#how-do-we-speed-things-up",
    "href": "miscellaneous.html#how-do-we-speed-things-up",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.8 How do we speed things up?",
    "text": "6.8 How do we speed things up?\nOur main tool for speeding up database searches is Indexing. Creating an index on a column speeds up searching through that particular column.\nDatabase Tuning is as much an art as it is a science. Too many indexes will make the database too big, whereas too few indexes will result in slow performance. This is why we hire database admins. Their work is incredibly important to keeping our data integrity and performing.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "miscellaneous.html#the-omop-data-model",
    "href": "miscellaneous.html#the-omop-data-model",
    "title": "\n6  Miscellaneous Grabbag\n",
    "section": "\n6.9 The OMOP Data Model",
    "text": "6.9 The OMOP Data Model\nThe database we’ve been using has been rigorously modeled using a data model called OMOP CDM (Common Data Model). OMOP is short for Observational Medical Outcomes Partnership, and it is designed to be a database format that standardizes data from systems into a format that can be combined with other systems to compare health outcomes across organizations.\nThis is a huge accomplishment, because there are a lot of different pieces of a healthcare system. Not only that, we need standardized vocabularies, and standardized units so that we are comparing the same things across the healthcare systems.\nThe following figure shows how chronic disesases are treated across (Link to paper) healthcare systems. This could not have been done without converting all of the electronic healthcare data to\n\n\nhttps://link.springer.com/article/10.1007/s10916-018-1076-5\n\nMuch more info about OMOP is here: OMOP Data Standardization.\n\ndbDisconnect(con)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Miscellaneous Grabbag</span>"
    ]
  },
  {
    "objectID": "tableref.html",
    "href": "tableref.html",
    "title": "\n7  Table Reference\n",
    "section": "",
    "text": "7.1 person table:\nSELECT * FROM person LIMIT 10;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nperson_id\ngender_concept_id\nyear_of_birth\nmonth_of_birth\nday_of_birth\nbirth_datetime\nrace_concept_id\nethnicity_concept_id\nlocation_id\nprovider_id\ncare_site_id\nperson_source_value\ngender_source_value\ngender_source_concept_id\nrace_source_value\nrace_source_concept_id\nethnicity_source_value\nethnicity_source_concept_id\n\n\n\n6\n8532\n1963\n12\n31\n1963-12-31\n8516\n0\nNA\nNA\nNA\n001f4a87-70d0-435c-a4b9-1425f6928d33\nF\n0\nblack\n0\nwest_indian\n0\n\n\n123\n8507\n1950\n4\n12\n1950-04-12\n8527\n0\nNA\nNA\nNA\n052d9254-80e8-428f-b8b6-69518b0ef3f3\nM\n0\nwhite\n0\nitalian\n0\n\n\n129\n8507\n1974\n10\n7\n1974-10-07\n8527\n0\nNA\nNA\nNA\n054d32d5-904f-4df4-846b-8c08d165b4e9\nM\n0\nwhite\n0\npolish\n0\n\n\n16\n8532\n1971\n10\n13\n1971-10-13\n8527\n0\nNA\nNA\nNA\n00444703-f2c9-45c9-a247-f6317a43a929\nF\n0\nwhite\n0\namerican\n0\n\n\n65\n8532\n1967\n3\n31\n1967-03-31\n8516\n0\nNA\nNA\nNA\n02a3dad9-f9d5-42fb-8074-c16d45b4f5c8\nF\n0\nblack\n0\ndominican\n0\n\n\n74\n8532\n1972\n1\n5\n1972-01-05\n8527\n0\nNA\nNA\nNA\n02fbf1be-29b7-4da8-8bbd-14c7433f843f\nF\n0\nwhite\n0\nenglish\n0\n\n\n42\n8532\n1909\n11\n2\n1909-11-02\n8527\n0\nNA\nNA\nNA\n0177d2e0-98f5-4f3d-bcfd-497b7a07b3f8\nF\n0\nwhite\n0\nirish\n0\n\n\n187\n8507\n1945\n7\n23\n1945-07-23\n8527\n0\nNA\nNA\nNA\n07a1e14d-73ed-4d3a-9a39-d729745773fa\nM\n0\nwhite\n0\nirish\n0\n\n\n18\n8532\n1965\n11\n17\n1965-11-17\n8527\n0\nNA\nNA\nNA\n0084b0fe-e30f-4930-b6d1-5e1eff4b7dea\nF\n0\nwhite\n0\nenglish\n0\n\n\n111\n8532\n1975\n5\n2\n1975-05-02\n8527\n0\nNA\nNA\nNA\n0478d6b3-bdb3-4574-9b93-cf448d725b84\nF\n0\nwhite\n0\nenglish\n0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Table Reference</span>"
    ]
  },
  {
    "objectID": "tableref.html#procedure_occurrence-table",
    "href": "tableref.html#procedure_occurrence-table",
    "title": "\n7  Table Reference\n",
    "section": "\n7.2 procedure_occurrence table:",
    "text": "7.2 procedure_occurrence table:\n\nSELECT * FROM procedure_occurrence LIMIT 10;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprocedure_occurrence_id\nperson_id\nprocedure_concept_id\nprocedure_date\nprocedure_datetime\nprocedure_type_concept_id\nmodifier_concept_id\nquantity\nprovider_id\nvisit_occurrence_id\nvisit_detail_id\nprocedure_source_value\nprocedure_source_concept_id\nmodifier_source_value\n\n\n\n3554\n343\n4107731\n1992-02-01\n1992-02-01\n38000275\n0\nNA\nNA\n22951\n0\n180256009\n4107731\nNA\n\n\n3741\n357\n4107731\n1990-11-14\n1990-11-14\n38000275\n0\nNA\nNA\n23670\n0\n180256009\n4107731\nNA\n\n\n3928\n399\n4107731\n1991-09-08\n1991-09-08\n38000275\n0\nNA\nNA\n26205\n0\n180256009\n4107731\nNA\n\n\n4115\n406\n4107731\n1990-02-13\n1990-02-13\n38000275\n0\nNA\nNA\n26759\n0\n180256009\n4107731\nNA\n\n\n4302\n411\n4107731\n1992-01-11\n1992-01-11\n38000275\n0\nNA\nNA\n27401\n0\n180256009\n4107731\nNA\n\n\n4489\n430\n4058899\n1938-10-11\n1938-10-11\n38000275\n0\nNA\nNA\n28537\n0\n168594001\n4058899\nNA\n\n\n4676\n442\n4107731\n1992-10-31\n1992-10-31\n38000275\n0\nNA\nNA\n29330\n0\n180256009\n4107731\nNA\n\n\n4863\n453\n4043071\n1984-03-20\n1984-03-20\n38000275\n0\nNA\nNA\n30237\n0\n228557008\n4043071\nNA\n\n\n5050\n469\n4043071\n1948-04-26\n1948-04-26\n38000275\n0\nNA\nNA\n31282\n0\n228557008\n4043071\nNA\n\n\n5237\n488\n4151422\n1962-09-21\n1962-09-21\n38000275\n0\nNA\nNA\n32616\n0\n269911007\n4151422\nNA",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Table Reference</span>"
    ]
  },
  {
    "objectID": "tableref.html#concept-table",
    "href": "tableref.html#concept-table",
    "title": "\n7  Table Reference\n",
    "section": "\n7.3 concept table",
    "text": "7.3 concept table\n\nSELECT * FROM concept LIMIT 10;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\nconcept_id\nconcept_name\ndomain_id\nvocabulary_id\nconcept_class_id\nstandard_concept\nconcept_code\nvalid_start_date\nvalid_end_date\ninvalid_reason\n\n\n\n35208414\nGastrointestinal hemorrhage, unspecified\nCondition\nICD10CM\n4-char billing code\nNA\nK92.2\n2007-01-01\n2099-12-31\nNA\n\n\n1118088\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\nRxNorm\nBranded Drug\nS\n213469\n1970-01-01\n2099-12-31\nNA\n\n\n40213201\npneumococcal polysaccharide vaccine, 23 valent\nDrug\nCVX\nCVX\nS\n33\n2008-12-01\n2099-12-31\nNA\n\n\n1557272\nAlendronate\nDrug\nRxNorm\nIngredient\nS\n46041\n1970-01-01\n2099-12-31\nNA\n\n\n4336464\nCoronary artery bypass graft\nProcedure\nSNOMED\nProcedure\nS\n232717009\n1970-01-01\n2099-12-31\nNA\n\n\n4295880\nIntramuscular injection\nProcedure\nSNOMED\nProcedure\nS\n76601001\n1970-01-01\n2099-12-31\nNA\n\n\n3020630\nProtein serum/plasma\nMeasurement\nLOINC\nLab Test\nS\n2885-2\n1970-01-01\n2099-12-31\nNA\n\n\n19129655\nAmpicillin 100 MG/ML Injectable Solution\nDrug\nRxNorm\nClinical Drug\nS\n789980\n2008-03-30\n2099-12-31\nNA\n\n\n44923712\ncelecoxib 200 MG Oral Capsule [Celebrex]\nDrug\nNDC\n11-digit NDC\nNA\n00025152531\n2000-01-01\n2099-12-31\nNA\n\n\n1569708\nOther diseases of digestive system\nCondition\nICD10CM\n3-char nonbill code\nNA\nK92\n2012-01-01\n2099-12-31\nNA",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Table Reference</span>"
    ]
  },
  {
    "objectID": "tableref.html#condition_occurrence-table",
    "href": "tableref.html#condition_occurrence-table",
    "title": "\n7  Table Reference\n",
    "section": "\n7.4 condition_occurrence table",
    "text": "7.4 condition_occurrence table\n\nSELECT * FROM condition_occurrence LIMIT 10;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncondition_occurrence_id\nperson_id\ncondition_concept_id\ncondition_start_date\ncondition_start_datetime\ncondition_end_date\ncondition_end_datetime\ncondition_type_concept_id\ncondition_status_concept_id\nstop_reason\nprovider_id\nvisit_occurrence_id\nvisit_detail_id\ncondition_source_value\ncondition_source_concept_id\ncondition_status_source_value\n\n\n\n4483\n263\n4112343\n2015-10-02\n2015-10-02\n2015-10-14\n2015-10-14\n32020\n0\nNA\nNA\n17479\n0\n195662009\n4112343\nNA\n\n\n4657\n273\n192671\n2011-10-10\n2011-10-10\nNA\nNA\n32020\n0\nNA\nNA\n18192\n0\nK92.2\n35208414\nNA\n\n\n4815\n283\n28060\n1984-02-15\n1984-02-15\n1984-02-25\n1984-02-25\n32020\n0\nNA\nNA\n18859\n0\n43878008\n28060\nNA\n\n\n4981\n293\n378001\n2005-11-07\n2005-11-07\n2005-12-07\n2005-12-07\n32020\n0\nNA\nNA\n19515\n0\n62106007\n378001\nNA\n\n\n5153\n304\n257012\n1974-07-30\n1974-07-30\n1974-11-05\n1974-11-05\n32020\n0\nNA\nNA\n20239\n0\n40055000\n257012\nNA\n\n\n5313\n312\n4134304\n1991-05-14\n1991-05-14\n1991-06-13\n1991-06-13\n32020\n0\nNA\nNA\n20658\n0\n263102004\n4134304\nNA\n\n\n5513\n326\n28060\n1979-09-23\n1979-09-23\n1979-10-06\n1979-10-06\n32020\n0\nNA\nNA\n21553\n0\n43878008\n28060\nNA\n\n\n5655\n334\n40481087\n1999-07-12\n1999-07-12\n1999-07-19\n1999-07-19\n32020\n0\nNA\nNA\n22124\n0\n444814009\n40481087\nNA\n\n\n5811\n341\n40481087\n1990-09-14\n1990-09-14\n1990-10-05\n1990-10-05\n32020\n0\nNA\nNA\n22784\n0\n444814009\n40481087\nNA\n\n\n5977\n351\n40481087\n1986-02-24\n1986-02-24\n1986-03-17\n1986-03-17\n32020\n0\nNA\nNA\n23405\n0\n444814009\n40481087\nNA",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Table Reference</span>"
    ]
  }
]